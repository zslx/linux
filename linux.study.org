* linux users
** 开发环境：git emacs gcc qmake sshd
   https://git-scm.com/book/zh/v2
   https://man.openbsd.org/sshd
   git clone /home/git/project.git
   git clone ssh://user@host/home/git/project.git
*** .gitignore
	首先要强调一点，这个文件的完整文件名就是“.gitignore”，注意最前面有个“.”。
	这样没有扩展名的文件在Windows下不太好创建，这里给出win7的创建方法：
	创建一个文件，文件名为：“.gitignore.”，注意前后都有一个点。保存之后系统会自动重命名为“.gitignore”。
	一般来说每个Git项目中都需要一个“.gitignore”文件，这个文件的作用就是告诉Git哪些文件不需要添加到版本管理中。

下面我们看看常用的规则：

/mtk/ 过滤整个文件夹
*.zip 过滤所有.zip文件
/mtk/do.c 过滤某个具体文件

很简单吧，被过滤掉的文件就不会出现在你的GitHub库中了，当然本地库中还有，只是push的时候不会上传。

需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：

!*.zip
!/mtk/one.txt

唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。

为什么要有两种规则呢？想象一个场景：我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理。
那么我们就需要使用：

/mtk/
!/mtk/one.txt

假设我们只有过滤规则没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！

最后需要强调的一点是，如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。

简单来说，出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。
git rm --cached FILENAME
所以大家一定要养成在项目开始就创建.gitignore文件的习惯，否则一旦push，处理起来会非常麻烦。

1、配置语法：
　　以斜杠“/”开头表示目录；
　　以星号“*”通配多个字符；
　　以问号“?”通配单个字符
　　以方括号“[]”包含单个字符的匹配列表；
　　以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；

　　此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；

2、示例：
　　（1）规则：fd1/*
　　　　  说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；
　　（2）规则：/fd1/*
　　　　  说明：忽略根目录下的 /fd1/ 目录的全部内容；
　　（3）规则：
/*
!.gitignore
!/fw/bin/
!/fw/sf/
说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；

# 语法规范
空行或是以#开头的行即注释行将被忽略。
可以在前面添加正斜杠/来避免递归,下面的例子中可以很明白的看出来与下一条的区别。
可以在后面添加正斜杠/来忽略文件夹，例如build/即忽略build文件夹。
可以使用!来否定忽略，即比如在前面用了*.apk，然后使用!a.apk，则这个a.apk不会被忽略。
*用来匹配零个或多个字符，如*.[oa]忽略所有以".o"或".a"结尾，*~忽略所有以~结尾的文件（这种文件通常被许多编辑器标记为临时文件）
[]用来匹配括号内的任一字符，如[abc]，也可以在括号内加连接符，如[0-9]匹配0至9的数
?用来匹配单个字符。
来个栗子：
# 忽略 .a 文件
*.a
# 但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件
!lib.a
# 仅在当前目录下忽略 TODO 文件， 但不包括子目录下的 subdir/TODO
/TODO
# 忽略 build/ 文件夹下的所有文件
build/
# 忽略 doc/notes.txt, 不包括 doc/server/arch.txt
doc/*.txt
# 忽略所有的 .pdf 文件 在 doc/ directory 下的
doc/**/*.pdf

** 用户和组的概念
1. 用户
   用户是能够获取系统资源的权限的集合.
2. 用户组的分类:
   a. 管理员 root  :具有使用系统所有权限的用户,其UID 为0.
   b. 普通用户  : 即一般用户,其使用系统的权限受限,其UID为500-60000之间.
   c. 系统用户 :保障系统运行的用户,一般不提供密码登录系统,其UID为1-499之间.
 
3. 与用户有关的文件/etc/passwd，/etc/shadow
   a. /etc/passwd文件：
      其格式：account：password：UID:GID:GECOS:diretory:shell
      account: 用户名或帐号
      password ：用户密码占位符
      UID：用户的ID号
      GID：用户所在组的ID号
      GECOS:用户的详细信息（如姓名，年龄，电话等）
      diretory：用户所的家目录
      shell：用户所在的编程环境
   b. /etc/shadow
      其格式：account：password：最近更改密码的日期：密码不可更该的天数：密码需要重新更改的天数：密码更改前的警告期限：密码过期的宽限时间：帐号失效日期：保留
4. 用户组
   用户组分类;
   a. 普通用户组:可以加入多个用户
   b. 系统组:一般加入一些系统用户
   c. 私有组(也称基本组):当创建用户时,如果没有为其指明所属组,则就为其定义一个私有的用户组,起名称与用户名同名.
注:私有组可以变成普通用户组,当把其他用户加入到该组中,则其就变成了普通组
5. 组是权限的容器
   如普通用户 a,b,c 所属组grp,则它们会继承组grp的权限
 
6. 与组有关的文件:/etc/group，/etc/gshadow
    /etc/group文件： 其格式:group_name:passwoerd:GID:user_list
     group_name:组名
     passwoerd:组密码
     GID:组的ID号
     user_list：以group_name为附加组的用户列表
7. 修改用户及用户组的命令：useradd，usermod， groupdd，userdel
   a．增加用户 ：useradd [options] username
      options：
                   1．-u ：UID
                   2．-g ：GID
                   3．-d ：指定用户家目录，默认是/home/username
                   4．-s ：指定用户所在的shell环境
                   5．-G：指定用户的附加组
       例如增加一用户wendy UID为1888 家目录/home/oracle，shell为/bin/sh
            #useradd Cu 1888 Cd /home/oracle Cs /bin/sh wendy
    b．修改用户：usermod  [options] username
            options：
                   1．-u ：UID
                   2．-g ：GID
                   3．-d ：指定用户家目录，默认是/home/username
                         -m 与-b 一起用表示把用户家目录的内容也移走
                   4．-s ：指定用户所在的shell环境
                   5．-G：指定用户的附加组
 
       例如修改用户wendy UID为1000 家目录/oracle，shell为/bin/bash
          #usermod Cu 1000 Cd  /oracle Cs /bin/bash -m wendy
          #usermod -G git,user steven #把steven同时加入git组和user组 
     c．增加用户组：groupadd   [options] groupname
           options
                   1．-g ：GID
        例如增加用户组grp UID为1001
          #groupadd Cg 1001 grp
     d．删除用户：userdel   [options]username
            options
              1．-r ：连同家目录一起删除
       例如删除用户wendy及家目录
           #userdel Cr wendy
** useradd
1.作用
useradd命令用来建立用户帐号和创建用户的起始目录，使用权限是终极用户。
2.格式
useradd [－d home] [－s shell] [－c comment] [－m [－k template]] [－f inactive] [－e expire ] [－p passwd] [－r] name
3.主要参数
－g：指定用户所属的起始群组。
－m：自动建立用户的登入目录。
－s：指定用户登入后所使用的shell。
－c：加上备注文字，备注文字保存在passwd的备注栏中。 
－d：指定用户登入时的启始目录。
－D：变更预设值。
－e：指定账号的有效期限，缺省表示永久有效。
－f：指定在密码过期后多少天即关闭该账号。
－G：指定用户所属的附加群组。
－M：不要自动建立用户的登入目录。
－n：取消建立以用户名称为名的群组。
－r：建立系统账号。
－u：指定用户ID号。
4.说明
useradd可用来建立用户账号，他和adduser命令是相同的。账号建好之后，再用passwd设定账号的密码。使用useradd命令所建立的账号，实际上是保存在/etc/passwd文本文件中。
5.应用实例
建立一个新用户账户，并设置ID：
＃useradd david -u 544
需要说明的是，设定ID值时尽量要大于500，以免冲突。因为Linux安装后会建立一些特别用户，一般0到499之间的值留给bin、mail这样的系统账号。

＃useradd Oracle -g oinstall -G dba
新创建一个oracle用户，这初始属于oinstall组，且同时让他也属于dba组。

＃useradd tomcat  -d /var/servlet/service -s /sbin/nologin
无法使用shell，且其用户目录至/var/servlet/service

* linux commands
find . -type f -name \*.h

* emacs
  # 我的 GitHub 积累与分享。
https://github.com/lujun9972/emacs-document
** 编码
1.查看当前buffer的编码：M-x describe-coding-system
2.列出所有编码：C-x <RET> r <TAB>
3.以指定编码重读当前buffer：C-x <RET> r utf-8，（revert-buffer-with-coding-system）
4.改变当前buffer的编码：C-x <RET> f utf-8，（set-buffer-file-coding-system）
5.设定下一步操作的编码格式：C-x <RET> c，（universal-coding-system-argument）
** elisp
You can evaluate an expression and see its result in any of several ways, including:
+ Put your cursor after the last close-paren and type C-j (control + j)
+ Put your cursor inside the expression and type M-C-x (alt + control + x)
+ Put your cursor after the last close-paren and type C-x C-e

*** Lexical Stuff
Comments:
Single-line only. They start with a semicolon:
(blah blah blah)   ;  I am a comment
(message "Hello World!") ; elisp first

Characters:
?x is the syntax for an ASCII character: ? followed by the character.
e.g.: ?a is ascii 97 ('a'), ? (that is, question-mark space) is ascii 32 (' ').
Some need to be escaped, such as ?\(, ?\) and ?\\
Emacs 22+ has unicode support. Out of scope for this primer.
`C-x 8 RET'

Numbers:
Integers are 29 bits of precision (not the usual 32). -32, 0, 157, etc.
Binary:         start with #b, e.g. #b10010110
Octal:          #o[0-7]+, e.g. #o377
Hexadecimal:    start with #x, e.g. #xabcd, #xDEADBEE
Floating-point: the usual. -10.005, 0.0, 3.14159265 (64 bits of precision.)
Scientific:     the usual. 6.02e23, 5e-10
The variables most-positive-fixnum and most-negative-fixnum are the largest
and smallest integers representable in Emacs Lisp without bignum support.

Strings:
Double-quoted only.
"He's said: \"Emacs Rules\" one time too many."

You can embed newlines in strings, like so:
"Oh Argentina!
Your little tin of pink meat
Soars o'er the Pampas"

Booleans:
The symbol t (just a letter 't' by itself) is true.
The symbol nil is false (and also means null).
In Emacs Lisp, nil is the only false value;
everything else evalutes to true in a boolean context,
including empty strings, zero, the symbol 'false, and empty vectors.
An empty list, '(), is the same thing as nil.

Arrays:
Elisp has fixed-sized arrays called "vectors".
[-2 0 2 4 6 8 10]
["No" "Sir" "I" "am" "a" "real" "horse"]
["hi" 22 120 89.6 2748 [3 "a"]]
Note that you do not (and cannot) use commas to separate the elements; use whitespace.
Vectors can have mixed-type elements, and can be nested.
You usually use the function make-vector to create them,
since literal vectors are singletons, which can be surprising.
# 操作
(setq xyz ["str" 3.14 [() ?d] 'some])
(aref xyz 2)
(aset xyz 0 "zsl")
(aref xyz 0)

Lists:
Lisp makes heavy use of linked lists, so there's lexical syntax for them.
Anything in parentheses is a list, but unless you quote it, it will be evaluated as a function call.
There are various ways to quote things in Lisp:
(quote (1 2 3)) ; produces the list (1 2 3) with no list-element evaluation
'(1 2 3)  ; apostrophe is shorthand for (quote (...))
          ; note that it goes _outside_ the left-paren
(list 1 (+ 1 1) 3) ; also produces (1 2 3), since it evaluates the elements first
`(1 ,(+ 1 1) 3)  ; another (1 2 3) via a template system called "backquote"
There's a lot more that could be said about lists, but other people have already said it.

Pairs:
You can set the head and tail (also known as car and cdr) fields of a lisp link-list node struct
(also known as a cons cell) directly, using it as a 2-element untyped struct.
The syntax is (head-value . tail-value), and you have to quote it (see above).

A common lookup-table data-structure for very small data sets is an associative list (known as an alist).
It's just a list of dotted pairs, like so:
'( (apple . "red")
   (banana . "yellow")
   (orange . "orange") )
Emacs Lisp has built-in hashtables, bit-vectors, and miscellaneous other data structures,
but there's no syntax for them; you create them with function calls.

*** Operators
  Some operations that are typically operators in other languages are function calls in elisp.
Equality:
Numeric equality: (= 2 (+ 1 1)) Single-equal. Yields t or nil. Works for floats too.
Not-numerically-equal: (/= 2 3) I know, it looks like assign-divide-equal. But it's not.

Value equality: (eq 'foo 2) Like Java ==. Works for ints, symbols, interned strings, and object references.
 Use eql for floating-point numbers (or just =).

Deep (structural) equality: use equal, as in:
(equal '(1 2 (3 4)) (list 1 2 (list 3 (* 2 2))))  ; true

The equal function is like Java's Object.equals(). Works for lists, vectors, strings, and just about anything else.

String
Strings don't have any operators, but there are lots of string functions. Some common ones:
(concat "foo" "bar" "baz")  ; yields "foobarbaz"
(string= "foo" "baz")  ; yields nil (false).  Can also use equal.
(substring "foobar" 0 3) ; yields "foo"
(upcase "foobar")  ; yields "FOOBAR"

Do M-x apropos RET \bstring\b RET to see a list of functions related to strings.
(apropos "string")

Arithmetic

Easiest to show as a table...
| C/Java/JS Operator | Emacs Lisp                         | Example         |                       Result |
| +                  | +                                  | (+ 1 2 3 4 5)   |                           15 |
| -                  | -                                  | (- 6 2 3)       |                            1 |
| *                  | *                                  | (* 2 -1 4.2)    |                         -8.4 |
| /                  | /                                  | (/ 10 3)        | 3 (use floats for float div) |
| %                  | %                                  | (% 10 3)        |                            1 |
| <<                 | lsh                                | (lsh 1 5)       |                           32 |
| >>                 | ash (negative amount)              | (ash -32 -4)    |                           -2 |
| >>>                | lsh (negative amount)              | (lsh 32 -4)     |                            2 |
| ++                 | incf (requires 'cl library)        | (incf x 6)      |                          x+6 |
| --                 | decf (ditto)                       | (decf x 5)      |                          x-5 |
| ? : (ternary)      | (if test-expr then-expr else-expr) | (if t 3 4)      |                            3 |
| &&                 | and                                | (and t t t nil) |                          nil |

|| or  (or nil nil nil t)  t
! (logical-not)	not	(not 3)	nil
~ (bit-not)	lognot	(lognot #b1001)	-10
^ (bit-xor)	logxor	(logxor 5 3)	6
& (bit-and)	logand	(logand 1 3)	1
| (bit-or)	logior	(logior 1 3)	3
<	<	(< 5 3)	nil
>	>	(> 5 3)	t
<=	<=	(<= 3 3)	t
>=	>=	(>= 5 3)	t
. (field access)	see setf below	n/a	n/a
[] (array access)	aref/aset	(aref [2 4 6] 1)	4

*** Statements
This section has some recipes for simple Java-like statements.
It's not comprehensive C just some recipes to get you going.

if/else
Case 1: no else clause: (if test-expr expr)
Example:
(if (>= 3 2)
  (message "hello there"))

Case 2: else clause: (if test-expr then-expr else-expr)
(if (today-is-friday)         ; test-expr
    (message "yay, friday")   ; then-expr
  (message "boo, other day")) ; else-expr

If you need multiple expressions (statements) in the then-expr,
you wrap them with a call to progn, which is like curly-braces in C or Java:
(if (zerop 0)
    (progn
      (do-something)
      (do-something-else)
      (etc-etc-etc)))

You don't need the progn around the else-expr
-C everything after the then-expr is considered to be part of the else-expr. Hence:
(if (today-is-friday)
    (message "yay, friday")
  (message "not friday!")
  (non-friday-stuff)
  (more-non-friday-stuff))

Case 3: else-if clause: Just nest 'em. Or use cond (see below).
(if 'sunday
    (message "sunday!")      ; then-expr
  (if 'saturday              ; else-if
      (message "saturday!")  ; next then-expr
    (message ("weekday!")))) ; final else

Case 4: no else-if, multiple body expressions C use when:
If you don't have an else-clause, then you can use the when macro, which provides an implicit progn:
(when (> 5 1)
  (blah)
  (blah-blah)
  (blah blah blah))

You can also use unless, which is like when but inverts the sense of the test:
(unless (weekend-p)
  (message "another day at work")
  (get-back-to-work))

switch
Elisp has two versions of the classic switch statement: cond and case.

Elisp does not have a table-lookup optimization for switch,
so cond and case are just syntax for nested if-then-else clauses.
However, if you have more than one level of nesting, it looks a lot nicer than if expressions.
The syntax is:
(cond
  (test-1
    do-stuff-1)
  (test-2
    do-stuff-2)
  ...
  (t
    do-default-stuff))

The do-stuff parts can be any number of statements, and don't need to be wrapped with a progn block.

Unlike classic switch, cond can handle any test expression (it just checks them in order), not just numbers.
The downside is that it doesn't have any special-casing for numbers, so you have to compare them to something.
Here's one that does string compares:
(cond
 ((equal value "foo")  ; case #1 C notice it's a function call to `equal' so it's in parens
  (message "got foo")  ; action 1
  (+ 2 2))             ; return value for case 1
 ((equal value "bar")  ; case #2 C also a function call (to `+')
  nil)                 ; return value for case 2
 (t                    ; default case C not a function call, just literal true
  'hello))             ; return symbol 'hello

The final t default clause is optional. The first matching clause is executed,
and the result of the entire cond expression is the result of the last expression in the matching clause.

The 'cl (Common Lisp) package bundled with Emacs provides case, 
which works if you're comparing numbers or symbols, 
so in a sense it works more like standard switch. Example:
(case 12
  (5 "five")
  (1 "one")
  (12 "twelve")
  (otherwise
   "I only know five, one and twelve."))  ; result:  "twelve"

With case you can use either t or otherwise for the default case, but it must come last.
It's cleaner to use case when you can get away with it, but cond is more general.

while
Elisp has a relatively normal while function: (while test body-forms)
Example, which you can evaluate in your *scratch* buffer:
(setq x 10
      total 0)
(while (plusp x)  ; while x is positive
  (message (int-to-string x))
  (incf total x)  ; add x to total
  (decf x))       ; subtract 1 from x

First we set two global variables, x=10 and total=0, then run the loop.
Then we can evaluate the expression total to see that its value is 55 (the sum of the numbers 1 to 10).

*** local variables
You declare function local variables with the let form.
The basic syntax is (let var-decl var-decl)
(let ((name1 value1)
      (name2 value2)
      name3
      name4
      (name5 value5)
      name6
      ...))
Each var-decl is either a single name, or (name initial-value).
You can mix initialized and uninitialized values in any order.
Uninitialized variables get the initial value nil.

You can have multiple let clauses in a function.
Code written for performance often collects all declarations into a single let at the top,
since it's a bit faster that way. Typically you should write your code for clarity first.

*** 学习
	http://www.woola.net/detail/2016-08-18-elisp.html

*** 补充，数组
   _____________________________________________
   |                                             |
   |          Sequence                           |
   |  ______   ________________________________  |
   | |      | |                                | |
   | | List | |             Array              | |
   | |      | |    ________       ________     | |
   | |______| |   |        |     |        |    | |
   |          |   | Vector |     | String |    | |
   |          |   |________|     |________|    | |
   |          |  ____________   _____________  | |
   |          | |            | |             | | |
   |          | | Char-table | | Bool-vector | | |
   |          | |____________| |_____________| | |
   |          |________________________________| |
   |_____________________________________________|

** Evil 将 Emacs变为Vim
   Evil-mode出现了. 它完美的模拟了Vim.
   Evil-mode的开发者公开宣称Evil-mode应该与Vim一模一样,
   任何不一样的地方都视为BUG.
   然后有一些相熟的资深Vim党也开始用这个Evil-mode,于是我知道了,这个mode确实很棒.
   https://github.com/lujun9972/emacs-document

   Emacs默认文本对象能力不强, 有了evil的拓展 C-o di" 轻轻松松搞定~
   http://www.kuqin.com/shuoit/20150727/347223.html
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (package-initialize)
Then:
  M-x package-refresh-contents
  M-x package-install RET evil

 (require 'evil)
 (evil-mode 1)

 Thanks Evil, 把 Emacs 打造成了理想的 “Vim 化的 Emacs Editor” 
 然后还在 .bashrc 里添加了alias vi='emacs -nw'，
 不要纠结是 Vim, Emacs 还是 Evil，他只是我的编辑器。

 默认配置完全模拟 Vim，除了用 Ctr-z 来切换模式。
 调整成在 Insert 模式下恢复 Emacs 键绑定，用 Esc 退到 Normal 模式。
 
 <N>C-e/C-y, <E>M-n/M-p
 <E>C-y/M-y yank, yank-pop

 Enable evil
 (setq evil-toggle-key "")
 ; remove default evil-toggle-key C-z, manually setup later
 (setq evil-want-C-i-jump nil)
; don't bind [tab] to evil-jump-forward
 (require 'evil)
 (evil-mode 1)
 ;; remove all keybindings from insert-state keymap, use emacs-state when editing
 (setcdr evil-insert-state-map nil)
 ;; ESC to switch back normal-state
 (define-key evil-insert-state-map [escape] 'evil-normal-state)
 ;; TAB to indent in normal-state
 (define-key evil-normal-state-map (kbd "TAB") 'indent-for-tab-command)
 ;; Use j/k to move one visual line insted of gj/gk
 (define-key evil-normal-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
 (define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
 (define-key evil-motion-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
 (define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)

** Ivy 只完成一件事，以及。。。
   https://github.com/lujun9972/emacs-document/blob/master/advertisement/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E4%BB%8EVim%E8%BF%81%E7%A7%BB%E5%88%B0Emacs+Evil.org
   Ivy 为实现最小化，简单化，可定制化，可发现化而努力.
   这四个形容词告诉我们很多Helm 和Ivy 这两个工具间不同的设计理念。

   在写这篇文章的时候，Ivy 只有大概3400行代码，为Ivy 所打造的生态系统：即Swipter 和 Counsel 也只有7500 行代码
   git clone https://github.com/abo-abo/swiper.git
   cd swiper
   ## Only ivy ?
   cat ivy.el | wc -l
   # => 3442
   
   ## count lines of code into the whole swiper ecosystem
   cat *.el | wc -l
   # => 7526

** 扩展推荐
   https://www.zhihu.com/question/21943533/answer/22145491
   company 取代auto-complete,更新很频繁
   yasnippet 代码模板,关键是可内嵌lisp代码执行，太强悍了!接下来唯一的限制就是你的想象力了
   js2-mode javascript开发神器(sublime之流和它根本不是一个数量级的)
   evil-mode 把emacs变成vim，基本vim有的它都有了比如text object，最酷的是可以写lisp自定义text object
   evil-leader 很简单的一个plugin,但是用好的话,让你效率成倍提升.
   evil-matchit 在成对的tag跳来跳去, vim的matchit移植版但更强大(我写的)
   evil-nerd-commenter 按行注释代码, nerd-comment的移植版(我写的)
   helmweb-mode 通吃html所有相关
   windows-numbering.el 子窗口跳转的终极方案,用过所有的编辑器,没有比这个好的了.
   smex 不用再记快捷键了
   # ====补充===
   我先入为主地认为提问者指的是需要安装的第三方扩展,Emacs自带的扩展我补充一下：
   org-mode gtd工具,神级别的软件,和git,vim,emacs是一个档次的
   winner-mode undo窗口layout很有用
   gnus 让我又爱又恨,Emacs其他插件太牛逼, 和yasnippet结合用,和company-mode,和evil等等,所以gnus要伴我终生了.
   ido 类似于helm，和helm各有千秋我都用,五五开,不过helm有个让我爱死的设置,可以选择何时使用ido,helm或者两者都不用.
   # 开源真的不错呃,世界级高手都是惺惺相惜的.不像那些专有软件,菜鸟开发,即使是同一个公司,还要互相往死里掐.
   imenu 显示当前文件函数列表,可以直接跳转到那去,完全可配置,支持所有语言flymake 实时语法检查,通吃所有语言
   flyspell 拼写检查,爱死了,是我见过的所有拼写检查最强大,如果你知道如何配置.
   # ====再补充===
   也许最好的插件就是Lisp语言本身,强大,简单易学,其语法看似诡异,于是自动过滤了菜鸟.
   我的另一个诀窍就是一旦发觉一个好的插件,立即调查原作者,
   务必把他所有开发的使用的工具调查清楚.
   比如mooz维护的的js2-mode让我爱不释手,于是我调查他开发的其他工具,
   keysnail - firefox模拟成Emacs,我用过的同类软件中最好的,细节无可挑剔
   percol - python开发的命令行工具,天才的作品,我现在的工作流主要就靠它,
   没有它我效率要大大降低.

* xwindow 和 字符界面切换
  # 未配置的字符界面，不支持中文。
** 一般有 ALT+CTRL+F1----F6为字符终端（字符界面），ALT+CTRL+F7为图形界面。
   不同的发行版本可能有一些差别，但切换方法都是一样的。

  1、按ALT+CTRL+F1切换到字符界面（Linux实体机）
  如果是VMware虚拟机安装的linux系统，则切换到字符界面的时候需要以下操作
  
  按下ALT+CTRL+SPACE(空格)，ALT+CTRL不松开，再按F1。这样就可以切换到字符界面了。
  
  2、按ALT+CTRL+F7切换到图形界面（Linux实体机）
  
  如果是VMware虚拟机安装的Linux系统，则切换到图形界面的时候需要以下操作
  
  按下ALT+CTRL+SPACE(空格)，ALT+CTRL不松开，再按F7。这样就可以切换到图形界面了。
    
  如果想 Ubuntu 在每次启动到 command prompt ，可以输入以下指令:
  
  $echo “false” | sudo tee /etc/X11/default-display-manager
  
  当下次开机时，就会以命令行模式启动（text模式，字符界面登录），如果想变回图形界面启动（X windows启动），可以入:
  
  $echo “/usr/sbin/gdm” | sudo tee /etc/X11/default-display-manager
  
  如果在Ubuntn以命令行模式启动，在字符终端想回到图形界面的话只需以下命令:
  $startx

** xterm/uxterm
   XTerm是一个X Window System上的终端模拟器，用来提供多个独立的SHELL输入输出。
   虚拟终端Xterm是X11标准指定的虚拟终端,历史非常悠久。
   Xterm的缺点:Xterm不支持中文。不过我们可以用Xterm的变种UXterm。
   # xterm 的所有相关设置都在一个名叫 .Xdefaults 的配置文件中
** 新终端： Tilda， F1一键呼出的终端。
** 添加完字体后, 可以用 xlsfonts 命令检查一下是否添加成功

* 安装谷歌浏览器，只需要三行代码： 
打开终端，输入 
cd /tmp 
对于谷歌Chrome32位版本，使用如下链接：
wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb

对于64位版本可以使用如下链接下载：
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 
下载完后，运行如下命令安装。

sudo dpkg -i google-chrome*; sudo apt-get -f install 

* 使用 so 中的类，具体的做法是：
1. 准备一份头文件，加入一个纯虚父类ABase，并声明createA,releaseA；
2. 在生成A.so的实现源码中，写业务类AHello，继承ABase，并导出上面提到的两个函数createA,releaseA；
3. 需要使用A.so的代码，使用dlopen打开so文件,dlsym导入createA,releaseA, 调用createA返回ABase指针类型的实际是AHello类型的实例，便可以使用这个AHello类实例了；
4. 调用raleaseA释放AHello实例。

注意：
1. 基类是纯虚类，不然编译器怎么在编译的时候知道AHello的实现在哪里？
2. 函数导入出需要加上extern “C”防止导出名字被修改。

class shape{ public:
   virtual void draw()=0;
};
class circle : public shape { public:
   void draw();
}

// the class factories
extern "C" shape* create() {
    return new circle;
}
extern "C" void destroy(shape* p) {
    delete p;
}

* libtool link warning xxx was moved.
  打开 xxx.la 查看 libdir 的路径是否正确？
* Linux下如何处理包含空格和特殊字符的文件名
包含特殊字符的文件名的例子，并不常见：

#232.txt
#bkf.txt
#bjsd3469.txt
#121nkfd.txt
-2232.txt
-fbjdew.txt
-gi32kj.txt
--321.txt
--bk34.txt
...
一个显而易见的问题是 - 在这个星球上有谁会创建和处理包含井号(#)，分号(;)，破折号(-)或其他特殊字符的文件/文件夹啊！

我和你想的一样，这种文件名确实不常见，不过在你必须得处理这种文件名的时候你的 shell 也不应该出错或罢工。而且技术上来说，Linux 下的一切比如文件夹、驱动器或其他所有的都被当作文件处理。

处理名字包含破折号(-)的文件
创建以破折号(-)开头的文件，比如 -abx.txt。

$ touch -abc.txt
测试输出
touch: invalid option -- 'b'
Try 'touch --help' for more information.
出现上面错误的原因是，shell 把破折号(-)之后的内容认作参数了，而很明显没有这样的参数，所以报错。

要解决这个问题，我们得告诉 Bash shell（是的，这里以及本文后面的大多数例子都是基于 BASH 环境）不要将特殊字符（这里是破折号）后的字符解释为参数。

有两种方法解决这个错误：

$ touch -- -abc.txt     [方法 #1]
$ touch ./-abc.txt      [方法 #2]
你可以通过运行命令 ls 或 ls -l 列出详细信息来检查通过上面两种方式创建的文件。

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 11:05 -abc.txt
要编辑上述文件可以这样：

$ nano -- -abc.txt 
或者 
$ nano ./-abc.txt 
注意：你可以将 nano 替换为任何其他你喜欢的编辑器比如说 vim：

$ vim -- -abc.txt 
或者 
$ vim ./-abc.txt 
如果只是简单地移动文件可以这样：

$ mv -- -abc.txt -a.txt
或者
$ mv -- -a.txt -abc.txt
删除这种文件，可以这样：

$ rm -- -abc.txt
或者
$ rm ./-abc.txt 
如果一个目录下有大量这种名字包含破折号的文件，要一次全部删除的话，可以这样：

$ rm ./-*
重要：

上面讨论的规则可以同样应用于名字中包含任意数量以及任意位置的连接符号的文件。就是说，-a-b-c.txt，ab-c.txt，abc-.txt，等等。

上面讨论的规则可以同样应用于名字中包含任意数量以及任意位置连接符号的文件夹，除了一种情况，在删除一个文件夹的时候你得这样使用rm -rf：

$ rm -rf -- -abc 或者 $ rm -rf ./-abc

处理名字包含井号(#)的文件
符号#在 BASH 里有非常特别的含义。#之后的一切都会被认为是评论，因此会被 BASH 忽略。

通过例子来加深理解：

创建一个名字是 #abc.txt 的文件：

$ touch #abc.txt
测试输出
touch: missing file operand
Try 'touch --help' for more information.
出现上面错误的原因是，BASH 将 #abc.txt 解释为评论而忽略了。所以命令 touch没有收到任何文件作为参数，所以导致这个错误。

要解决这个问题，你可能需要告诉 BASH 不要将 # 解释为评论。

$ touch ./#abc.txt
或者
$ touch '#abc.txt'
检查刚创建的文件：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 12:14 #abc.txt
现在创建名字中除了开头的其他地方包含 # 的文件。

$ touch ./a#bc.txt
$ touch ./abc#.txt    
或者
$ touch 'a#bc.txt'
$ touch 'abc#.txt'
运行 ‘ls -l‘ 来检查：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 12:16 a#bc.txt
-rw-r--r-- 1 avi avi 0 Jun  8 12:16 abc#.txt
如果同时创建两个文件（比如 a 和 #bc）会怎么样：

$ touch a.txt #bc.txt
检查刚创建的文件：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 12:18 a.txt
很明显上面的例子中只创建了文件 a 而文件 #bc 被忽略了。对于上面的情况我们可以这样做，

$ touch a.txt ./#bc.txt
或者
$ touch a.txt '#bc.txt'
检查一下：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 12:20 a.txt
-rw-r--r-- 1 avi avi 0 Jun  8 12:20 #bc.txt
可以这样移动文件：

$ mv ./#bc.txt ./#cd.txt
或者
$ mv '#bc.txt' '#cd.txt'
这样拷贝：

$ cp ./#cd.txt ./#de.txt
或者
$ cp '#cd.txt' '#de.txt'
可以使用你喜欢的编辑器来编辑文件：

$ vi ./#cd.txt
或者
$ vi '#cd.txt'
 
$ nano ./#cd.txt
或者
$ nano '#cd.txt'
这样删除：

$ rm ./#bc.txt 
或者
$ rm '#bc.txt'
要删除所有以井号（#）开头的文件，可以这样：

# rm ./#*
处理名字包含分号(;)的文件
如果你还不知道的话，分号在 BASH 里起到命令分隔的作用，其他 shell 可能也是一样的。分号作为分隔符可以让你一次执行几个命令。你碰到过名字包含分号的文件吗？如果没有的话，这里有例子。

创建一个名字包含分号的文件。

$ touch ;abc.txt
测试输出
touch: missing file operand
Try 'touch --help' for more information.
bash: abc.txt: command not found
出现上面错误的原因是，在运行上面命令的时候 BASH 会把 touch 解释为一个命令但是在分号前没有任何文件参数，所以报告错误。然后报告的另一个错误找不到命令 abc.txt，只是因为在分号后 BASH 会期望另一个新的命令，而 abc.txt 并不是一个命令。

要解决这个问题，我们得告诉 BASH 不要将分号解释为命令分隔符，例如：

$ touch ./';abc.txt'
或者
$ touch ';abc.txt'
注意：我们将文件名用单引号 '' 包含起来。这样可以告诉 BASH 分号 ; 是文件名的一部分而不是命令分隔符。

对名字包含分号的文件和文件夹的其他操作（就是，拷贝、移动、删除）可以直接将名字用单引号包含起来就好了。

处理名字包含其他特殊字符的文件/文件夹
文件名包含加号 (+)
不需要任何特殊处理，按平时的方式做就好了，比如下面测试的文件名。

$ touch +12.txt 
文件名包含美元符 ($)
你需要将文件名用单引号括起来，像处理分号那样的方式。然后就很简单了。

$ touch '$12.txt'
文件名包含百分号 (%)
不需要任何特殊处理，当作一个普通文件就可以了。

$ touch %12.txt
文件名包含星号 (*)
需要用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改。）

$ touch *12.txt
注意：当你需要删除星号开头的文件时，千万不要用类似下面的命令。

$ rm *
或者
$ rm -rf *
而是用这样的命令，(LCTT 译注：此处原文有误，已修改）

$ rm ./'*.txt'
文件名包含叹号 (!)
只要将文件名用单引号括起来，其他的就一样了。

$ touch '!12.txt'
文件名包含小老鼠 (@)
没有什么特别的，可以将名字包含小老鼠的文件当作普通文件。

$ touch '@12.txt'
文件名包含 ^
不需要特殊处理。可以将名字包含 ^ 的文件当作普通文件。

$ touch ^12.txt
文件名包含 (&)
将文件名用单引号括起来，然后就可以操作了。

$ touch '&12.txt'
文件名包含括号 ()
如果文件名包含括号，你需要将文件名用单引号括起来。

$ touch '(12.txt)'
文件名包含花括号 {}
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch '{12.txt}'
文件名包含尖括号 <>
名字包含尖括号的文件需要用单引号括起来。

$ touch '<12.txt>'
文件名包含方括号 [ ]
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch '[12.txt]'
文件名包含下划线 (_)
这个非常普遍，不需要特殊对待。当作普通文件随意处理。

$ touch _12.txt
文件名包含等号 (=)
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch '=12.txt'
处理反斜杠 ()
反斜杠会告诉 shell 忽略后面字符的特殊含义。你必须将文件名用单引号括起来，就像处理分号那样。其他的就没什么了。

$ touch '\12.txt'
包含斜杠的特殊情形
除非你的文件系统有问题，否则你不能创建名字包含斜杠的文件。没办法转义斜杠。

所以如果你能创建类似 ‘/12.txt’ 或者 ‘b/c.txt’ 这样的文件，那要么你的文件系统有问题，或者支持 Unicode，这样你可以创建包含斜杠的文件。只是这样并不是真的斜杠，而是一个看起来像斜杠的 Unicode 字符。

文件名包含问号 (?)
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch '?12.txt'
文件名包含点 (.)
在 Linux 里以点 (.) 开头的文件非常特别，被称为点文件。它们通常是隐藏的配置文件或系统文件。你需要使用 ls 命令的 ‘-a‘ 或 ‘-A‘ 开关来查看这种文件。

创建，编辑，重命名和删除这种文件很直接。

$ touch .12.txt
注意：在 Linux 里你可能碰到名字包含许多点 (.) 的文件。不像其他操作系统，文件名里的点并不意味着分隔名字和扩展后缀。你可以创建名字包含多个点的文件：

$ touch 1.2.3.4.5.6.7.8.9.10.txt
检查一下：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 14:32 1.2.3.4.5.6.7.8.9.10.txt
文件名包含逗号 (,)
你可以在文件名中使用逗号，可以有任意多个而不用特殊对待。就像平时普通名字文件那样处理。

$ touch ,12.txt
或者
$ touch ,12,.txt
文件名包含冒号 (:)
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch ':12.txt'
或者
$ touch ':12:.txt'
文件名包含引号（单引号和双引号）
要在文件名里使用引号，我们需要使用交替规则。例如，如果你需要在文件名里使用单引号，那就用双引号把文件名括起来。而如果你需要在文件名里使用双引号，那就用单引号把文件名括起来。（LCTT 译注：或者如果单引号和双引号混杂的情况，你也可以用反斜杠转义。）

$ touch "15'.txt"
 
以及
 
$ touch '15".txt'
文件名包含波浪号 (~)
Linux 下一些像 emacs 这样的文本编辑器在编辑文件的时候会创建备份文件。这个备份文件的名字是在原文件名后面附加一个波浪号。你可以在文件名任意位置使用波浪号，例如：

$ touch ~1a.txt
或者
$touch 2b~.txt
文件名包含空格
创建名字的字符/单词之间包含空格的文件，比如 “hi my name is avishek.txt”。

最好不要在文件名里使用空格，如果你必须要分隔可读的名字，可以使用下划线或横杠。不过，你还是需要创建这样的文件的话，你可以用反斜杠来转义下一个字符。要创建上面名字的文件可以这样做。

$ touch hi\ my\ name\ is\ avishek.txt
 
hi my name is avishek.txt
我已经尝试覆盖你可能碰到的所有情况。上面大多数测试都在 BASH Shell 里完成，可能在其他 shell 下会有差异。

如果你觉得我遗漏了什么（这很正常也符合人性），请把你的建议发表到下面的评论里。保持联系，多评论。不要走开！求点赞求分享求扩散！
