* 写给支持和反对《完全用Linux工作》的人们
作者：王垠 
http://docs.huihoo.com/homepage/shredderyin/
编程是一种创造性的工作，是一门艺术。精通任何一门艺术，
都需要很多的练习和领悟，所以这里提出的“智慧”，
并不是号称一天瘦十斤的减肥药，它并不能代替你自己的勤奋。
然而由于软件行业喜欢标新立异，喜欢把简单的事情搞复杂，
我希望这些文字能给迷惑中的人们指出一些正确的方向，
让他们少走一些弯路，基本做到一分耕耘一分收获。

http://yinwang0.lofter.com/post/183ec2_c910628
shredderyin [AT] gmail.com

在一阵阵唾骂和欢呼声中，《完全用linux工作》被转载到了天涯海角。
很多人支持我，也有很多人唾骂我。我不知道它是怎样流传到那么多地方，
其实我不知道它都被转到哪里去了…… 我知道现在这篇文章又会罗里罗索写很长
（因为我计划写这样一个东西已经很久了，坐在Emacs前面总是有一种巫师在炼丹的感觉……），
所以先提出中心思想吧。中心思想就是： 

我只是一个傻瓜。看《完全用Linux 工作》的时候请用你们自己的判断力。 
几乎所有人都承认，那篇文章很偏激。当时的情况是这样，我用 Linux 的时候被一个同学鄙视了，
说："你怎么用像 DOS 一样落后的东西，真土！看我漂亮的 Win2000..."
这跟当面嘲笑别人老婆或者妈妈有什么区别？我义愤填膺啊，就几乎跟他吵起来。
然后就写出了这篇文章放在主页上，叫了几个人来看。接着我珍爱的 TeX 又受到众人鄙视，
于是我又写了一篇文章打击 Word，然后把 TeX 捧上了天。道理很简单，鄙视我喜欢的东西的人就是敌人
 --邪教徒或者恐怖分子--他支持的我就反对，他反对的我就支持。为了使人信服，举例必用大科学家，世界一流大学，一流实验室的名号，虽然我不跟其中任何一种沾边。还好那时候我还不认识上帝，要不就打他的名字了。论据不管是实际经历还是自己推测的，先写上去再说。扬眉吐气啊！隔壁微软研究院的哥们居然都被我打动了，开始写 Linux 程序，学用 LaTeX 和 Emacs。不过几天之后我就把它删掉了，因为我自己都感觉到偏激。 

于是就没管那篇文章了。可是没想到它竟然已经被转载到那么多地方，似乎引起不小的波澜。有段时间每天都收到十几封email，国内的，国外的，问技术问题的，夸我的，骂我的，讲道理的，鄙视我的，想交朋友的，语重心长的，号称要删掉机器上的 Windows 的…… 我的主页居然也占据了"王垠"在 Google 上的首选位置，把那个日本的什么王公贵族"李王垠殿下"都挤下去了。大家似乎都知道我天花乱坠的本事了，有人就想找我写文章向别人推荐商业软件，我很后悔没有趁机狠狠赚一笔。走到图书馆，亮出借书证，管理员张大了嘴说："哇！你就是那个 Linux 牛人啊！"，也不知道他是褒是贬。甚至有人把他的 BBS 昵称都改成了"坚决拥护精神领袖花生" （花生是我的外号）。为此还骗到了好几顿报告（报告"是清华专用动词，意思是请客吃饭）。虽然我觉得自己身上没有什么值得自豪的东西，但是又有点为自己兴风作浪的本事感到惊讶。虽然我一再告诫自己要谦虚，但是不由的有一种毛泽东，甘地，甚至摩西的感觉。我更加体会到"网络上没有人知道你是一头猪"的真理性。其实，不但网络上没有人知道我是一头猪，实际生活中也没有人知道，其实我是一头笨猪。 

这么长的时间之后，还有人写信给我说"深受鼓舞"，"提壶灌顶"，"对不起我还在用 Windows 给你写信"，"真想删掉Windows 啊" …… 我很好奇，我的文章真的有那么大的威力？我再看这篇文章，觉得有点惨不忍睹，看了开头就不忍心再看下去。我告诉同学我很后悔写了一篇这么偏激的文章，可是他"徼枉必须过正，你没有错"，所以我也搞不清楚自己这样写对不对，这样自责对不对。就像我从来不敢看自己照片，却有时被人称为帅哥，就让我无法判断自己是否帅一样。所以现在我就开始怀疑我自己是否真是一头笨猪。也许多年以后，我会正确的评价我的想法。就像我现在觉得我15岁的照片挺养眼一样，也许我会发现自己其实是一头聪明猪？ 

写这篇文章不是为了让自己免得被骂，也不是为了显示高深的猪的哲理。只是因为我深深的感到人应该有自己的判断力，不要简单的接受别人说的 DO's 和 DONT's。怀疑一切，同时又敞开心扉去了解一切。

# 看到真正优秀的人，才觉得自己多么愚蠢，白痴，浅薄，低劣。
# 看到真正优秀的人，才发觉自己多么愚蠢，白痴，浅薄，低劣。
# 被人言中，尤其是缺点，是很不爽的感受。 于是自我防护，盲目的回应
在古代，可称为士或君子。现在没有合适的词语。
# 许多人其实挺不错的，就是欠缺一点打磨

* 每天留点时间磨刀：从总体审视、学习或巩固深化、熟能生巧。
 # emacs, notes.org
 # git
 # Vipassana
 # 长期使用emacs会导致左手小拇指健康状况恶化，甚至肌肉萎缩（众所周知vim是esc到死，而emacs是ctrl到死）
* 开源世界 http://docs.huihoo.com/open-source/guide/
* Wine的真实意思应当是Windows Environment的缩写，即WinE
  Wine （“Wine Is Not an Emulator” 的首字母缩写）
  是一个能够在多种 POSIX-compliant 操作系统（诸如 Linux，macOS 及 BSD 等）上运行 Windows 应用的兼容层。

GUI方法。
具体方法如下：
1. 点击Applications（应用程序）菜单。
2. 输入software。
3. 点击Software & Updates（软件和更新）。
4. 点击Other Software（其他软件）选项卡。
5. 点击Add（添加）。
6．在APT行部分输入ppa:ubuntu-wine/ppa（见图2）。
7. 点击Add Source（添加来源）。
8. 输入你的sudo密码。
9. 点击Authenticate（验证）。
10. 点击Close（关闭）。
11. 出现提示后，点击Reload（重新装入）。
12. 打开Software Center（软件中心）。
13. 搜索Wine。
14. 点击Wine项，然后点击Install（安装）。
15. 让安装完成。

安装和运行应用程序
不妨安装一个非常受编程人员欢迎的记事本：Notepad++。你需要从不包括第三方应用程序安装选项的位置下载文件（这可能会导致应用程序安装失败）。为了保险起见，从Filehippo（http://www.filehippo.com/zh/download_notepad）下载Notepad++安装程序。你会在Downloads目录下找到Notepad的.exe文件。右击该文件，选择Open in Wine Windows Program Loader（使用Wine Windows程序装载器打开，图3）。

白金级（Platinum）：直接就可以无缝运行的应用程序。
黄金级（Gold）：进行一些必要的改动后才能运行的应用程序。
白银级（Silver）：运行时会出现小问题的应用程序，但并不影响使用。
你还会发现有些应用程序被列为垃圾（Garbage），这意味着它们没法安装及/或没法运行。

* MinGW: Minimalist GNUfor Windows。
   它是一个可自由使用和自由发布的Windows特定头文件和使用GNU工具集导入库的集合，
   允许你在GNU/Linux和Windows平台生成本地的Windows程序,
   而不需要第三方C运行时（C Runtime）库。
 

* 开发环境：git emacs gcc qmake sshd
** 内存检查
http://valgrind.org/downloads/current.html
** gdb program core
  要定位进程挂在哪一行只需要3个操作:
  ulimit -c unlimited
  gcc -o main -g a.c
  gdb main /tmp/core-main-10815 
  就可以啦。
  
GDB中的命令固然很多，但我们只需掌握其中十个左右的命令，就大致可以完成日常的基本的程序调试工作。
(gdb) bt
(gdb) where
(gdb) list

 命令	 解释	 示例
file <文件名>	加载被调试的可执行程序文件。
因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。	(gdb) file gdb-sample

r	Run的简写，运行被调试的程序。
如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。	(gdb) r

c	Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。	(gdb) c

b <行号>
b <函数名称>
b *<函数名称>
b *<代码地址>
d [编号]
b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。
其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。
d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。

(gdb) b 8
(gdb) b main
(gdb) b *main
(gdb) b *0x804835c
(gdb) d

s, n
s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数； 相当于其它调试器中的“Step Into (单步跟踪进入)”；
n: 执行一行源程序代码，此行代码中的函数调用也一并执行。相当于其它调试器中的“Step Over (单步跟踪)”。
这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。
(gdb) s
(gdb) n

si, ni	si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。	(gdb) si
(gdb) ni

p <变量名称>	Print的简写，显示指定变量（临时变量或全局变量）的值。	(gdb) p i
(gdb) p nGlobalVar

display ...
undisplay <编号>
# display，设置程序中断后欲显示的数据及其格式。
例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令
“display /i $pc”
其中 $pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。
undispaly，取消先前的display设置，编号从1开始递增。
(gdb) display /i $pc
(gdb) undisplay 1

i	Info的简写，用于显示各类信息，详情请查阅“help i”。	(gdb) i r
q	Quit的简写，退出GDB调试环境。	(gdb) q
help [命令名称]	GDB帮助命令，提供对GDB名种命令的解释说明。
如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。	(gdb) help display

* users
** 灾难：把自己从sudo组删除了！
# 危险命令 usermod -a -G xyz username 忘了加 -a
sudo -i
也无法切换到root，无奈只能求助全能的谷歌，使用如下命令
pkexec visudo
便可已编辑sudoers了
# 改错了用户组
zsl@ubuntu:~$ grep zsl /etc/passwd
zsl:x:1000:1000:ubuntu64zsl,,,:/home/zsl:/bin/bash

zsl@ubuntu:~$ grep zsl /etc/group

adm:x:4:syslog,zsl
cdrom:x:24:zsl
sudo:x:27:zsl
dip:x:30:zsl
plugdev:x:46:zsl
lpadmin:x:121:zsl
zsl:x:1000:
sambashare:x:131:zsl

zsl@ubuntu:~$ less /etc/sudoers
/etc/sudoers: Permission denied


当时的场景:root无密码,另外只有fick用户可以登录,而fick用户已经不属于sudo组,尝试结果发现某网友的方案是对的:

重启系统进入ubuntu的恢复模式(至于如何进,网上也有各种说法,有的说开机时按shift键,有的说按ESC键,我的是过完自检后立即按ESC键起作用的);
在恢复模式下,进入root shell界面;
关键:恢复模式下,filesystem为只读的,需要以读写模式重新挂载根目录,执行命令如下:
mount -o remount,rw /
再用以下命令给用户添加sudo组
usermod -a -G adm,cdrom,sudo,dip,plugdev,lpadmin,sambashare username

OK,万事大吉了.这个时候可以su到自己的用户下,通过id命令查看所属组.
你应该也注意到了,为指定用户添加指定组的命令要加-a选项才是添加,如果不加该选项,就直接覆盖了.
疑惑，这不是安全漏洞吗？

另一个修改读写权限的方法：
进入GRUB菜单，在高级选择中选择Recovery mode模式，键盘按“e”键进入编辑模式。
在编辑模式中通过上下键寻找到RO修改为RW模式(可写入恢复模式)。如下图，然后按crtl+X进入系统。
通过上下键选择root命令行，点击enter键。

** 用户和组的概念
1. 用户
   用户是能够获取系统资源的权限的集合.
2. 用户组的分类:
   a. 管理员 root  :具有使用系统所有权限的用户,其UID 为0.
   b. 普通用户  : 即一般用户,其使用系统的权限受限,其UID为500-60000之间.
   c. 系统用户 :保障系统运行的用户,一般不提供密码登录系统,其UID为1-499之间.
 
3. 与用户有关的文件/etc/passwd，/etc/shadow
   a. /etc/passwd文件：
      其格式：account：password：UID:GID:GECOS:diretory:shell
      account: 用户名或帐号
      password ：用户密码占位符
      UID：用户的ID号
      GID：用户所在组的ID号
      GECOS:用户的详细信息（如姓名，年龄，电话等）
      diretory：用户所的家目录
      shell：用户所在的编程环境
   b. /etc/shadow
      其格式：account：password：最近更改密码的日期：密码不可更该的天数：密码需要重新更改的天数：密码更改前的警告期限：密码过期的宽限时间：帐号失效日期：保留
4. 用户组
   用户组分类;
   a. 普通用户组:可以加入多个用户
   b. 系统组:一般加入一些系统用户
   c. 私有组(也称基本组):当创建用户时,如果没有为其指明所属组,则就为其定义一个私有的用户组,起名称与用户名同名.
注:私有组可以变成普通用户组,当把其他用户加入到该组中,则其就变成了普通组
5. 组是权限的容器
   如普通用户 a,b,c 所属组grp,则它们会继承组grp的权限
 
6. 与组有关的文件:/etc/group，/etc/gshadow
    /etc/group文件： 其格式:group_name:passwoerd:GID:user_list
     group_name:组名
     passwoerd:组密码
     GID:组的ID号
     user_list：以group_name为附加组的用户列表
7. 修改用户及用户组的命令：useradd，usermod， groupdd，userdel
   a．增加用户 ：useradd [options] username
      options：
                   1．-u ：UID
                   2．-g ：GID
                   3．-d ：指定用户家目录，默认是/home/username
                   4．-s ：指定用户所在的shell环境
                   5．-G：指定用户的附加组
       例如增加一用户wendy UID为1888 家目录/home/oracle，shell为/bin/sh
            #useradd –u 1888 –d /home/oracle –s /bin/sh wendy
    b．修改用户：usermod  [options] username
            options：
                   1．-u ：UID
                   2．-g ：GID
                   3．-d ：指定用户家目录，默认是/home/username
                         -m 与-b 一起用表示把用户家目录的内容也移走
                   4．-s ：指定用户所在的shell环境
                   5．-G：指定用户的附加组
 
       例如修改用户wendy UID为1000 家目录/oracle，shell为/bin/bash
          #usermod –u 1000 –d  /oracle –s /bin/bash -m wendy
          #usermod -G git,user steven #把steven同时加入git组和user组 
     c．增加用户组：groupadd   [options] groupname
           options
                   1．-g ：GID
        例如增加用户组grp UID为1001
          #groupadd –g 1001 grp
     d．删除用户：userdel   [options]username
            options
              1．-r ：连同家目录一起删除
       例如删除用户wendy及家目录
           #userdel –r wendy
** useradd
1.作用
useradd命令用来建立用户帐号和创建用户的起始目录，使用权限是终极用户。
2.格式
useradd [－d home] [－s shell] [－c comment] [－m [－k template]] [－f inactive] [－e expire ] [－p passwd] [－r] name
3.主要参数
－g：指定用户所属的起始群组。
－m：自动建立用户的登入目录。
－s：指定用户登入后所使用的shell。
－c：加上备注文字，备注文字保存在passwd的备注栏中。 
－d：指定用户登入时的启始目录。
－D：变更预设值。
－e：指定账号的有效期限，缺省表示永久有效。
－f：指定在密码过期后多少天即关闭该账号。
－G：指定用户所属的附加群组。
－M：不要自动建立用户的登入目录。
－n：取消建立以用户名称为名的群组。
－r：建立系统账号。
－u：指定用户ID号。
4.说明
useradd可用来建立用户账号，他和adduser命令是相同的。账号建好之后，再用passwd设定账号的密码。使用useradd命令所建立的账号，实际上是保存在/etc/passwd文本文件中。
5.应用实例
建立一个新用户账户，并设置ID：
＃useradd david -u 544
需要说明的是，设定ID值时尽量要大于500，以免冲突。因为Linux安装后会建立一些特别用户，一般0到499之间的值留给bin、mail这样的系统账号。

＃useradd Oracle -g oinstall -G dba
新创建一个oracle用户，这初始属于oinstall组，且同时让他也属于dba组。

＃useradd tomcat  -d /var/servlet/service -s /sbin/nologin
无法使用shell，且其用户目录至/var/servlet/service

** others
chmod - modify file access rights
su - temporarily become the superuser
sudo - temporarily become the superuser
chown - change file ownership
chgrp - change a file's group ownership

* yum命令软件包管理
  yum命令是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，
  可以使系统管理人员交互和自动化地更细与管理RPM软件包，
  够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，
  且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。
  yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。
  语法 yum(选项)(参数)
  选项
  -h：显示帮助信息； -y：对所有的提问都回答“yes”；
  -c：指定配置文件； -q：安静模式； -v：详细模式； -d：设置调试等级（0-10）；
  -e：设置错误等级（0-10）； -R：设置yum处理一个命令的最大等待时间； -C：完全从缓存中运行，而不去下载或者更新任何头文件。
  参数
  install：安装rpm软件包； update：更新rpm软件包； check-update：检查是否有可用的更新rpm软件包；
  remove：删除指定的rpm软件包； list：显示软件包的信息； search：检查软件包的信息；
  info：显示指定的rpm软件包的描述信息和概要信息； clean：清理yum过期的缓存； shell：进入yum的shell提示符；
  resolvedep：显示rpm软件包的依赖关系； localinstall：安装本地的rpm软件包； localupdate：显示本地rpm软件包进行更新；
  deplist：显示rpm软件包的所有依赖关系。
  实例
  部分常用的命令包括：
  自动搜索最快镜像插件：yum install yum-fastestmirror
  安装yum图形窗口插件：yum install yumex
  查看可能批量安装的列表：yum grouplist
  安装 yum install #全部安装
  yum install package1 #安装指定的安装包package1
  yum groupinsall group1 #安装程序组group1
  更新和升级 yum update #全部更新
  yum update package1 #更新指定程序包package1
  yum check-update #检查可更新的程序
  yum upgrade package1 #升级指定程序包package1
  yum groupupdate group1 #升级程序组group1
  查找和显示 yum info package1 #显示安装包信息package1
  yum list #显示所有已经安装和可以安装的程序包
  yum list package1 #显示指定程序包安装情况package1
  yum groupinfo group1 #显示程序组group1信息yum
  search string 根据关键字string查找安装包
  删除程序 yum remove | erase package1 #删除程序包package1
  yum groupremove group1 #删除程序组group1
  yum deplist package1 #查看程序package1依赖情况
  清除缓存 yum clean packages #清除缓存目录下的软件包
  yum clean headers #清除缓存目录下的 headers
  yum clean oldheaders #清除缓存目录下旧的 headers
来自: http://man.linuxde.net/yum

* commands   http://linuxcommand.org/index.php
  http://man.linuxde.net/yum
  type - Display information about command type
  which - Locate a command
  help - Display reference page for shell builtin
  man - Display an on-line command reference
find . -type f -name \*.h
** awk , sed , grep 利器
  gerp 查找, sed 编辑, awk 根据内容分析并处理.
  $file * |awk '{print $1 $2}'|awk '{FS=":"} {print $1" " $1"."$2}' > args.txt
*** awk(关键字:分析&处理) 一行一行的分析处理
awk '条件类型1{动作1}条件类型2{动作2}' filename,
awk 也可以读取来自前一个指令的 standard input
Actions 是由许多awk指令构成. 而awk的指令与 C 语言中的指令十分类似.

相对于sed常常用于一整行处理, awk则比较倾向于一行当中分成数个"字段"(区域)来处理,
默认的分隔符是空格键或tab键。

例如:
last -n 5 | awk '{print $1 "\t" $3}' 这里大括号内$1"\t"$3 之间不加空格也可以,
不过最好还是加上个空格, 另外注意"\t"是有双引号的, 因为本身这些内容都在单引号内。

$0 代表整行 $1代表第一个区域, 依此类推

awk的处理流程是:
1. 读第一行, 将第一行资料填入变量 $0, $1... 等变量中
2. 依据条件限制, 执行动作
3. 接下来执行下一行

所以, awk一次处理是一行, 而一次中处理的最小单位是一个区域。
另外还有3个变量, NF: 每一行处理的字段数, NR 目前处理到第几行 FS 目前的分隔符。
逻辑判断 > < >= <= == !== , 赋值直接使用=

cat /etc/passwd | awk '{FS=":"} $3<10 {print $1 "\t" $3}'
首先定义分隔符为:, 然后判断, 注意看, 判断没有写在{}中, 然后执行动作,
FS=":"这是一个动作, 赋值动作, 不是一个判断, 所以写在{}中。

BEGIN END, 给程序员一个初始化和收尾的工作, BEGIN之后列出的操作在{}内
将在awk开始扫描输入之前执行, 而END{}内的操作, 将在扫描完输入文件后执行。
awk '/test/ {print NR}' abc
将带有test的行的行号打印出来, 注意//之间可以使用正则表达式
awk {}内, 可以使用 if else ,for(i=0;i<10;i++), i=1 while(i<NF)
可见, awk的很多用法都等同于C语言, 比如"\t" 分隔符, print的格式,
 if, while, for 等等

awk程序中允许呼叫Shell指令. 并提供管道解决awk与系统间数据传递的问题. 所以awk很容易使用系统资源. 读者可利用这个特点来编写某些适用的系统工具.
awk 提供与 UNIX 用法近似的 pipe, 其记号亦为 "|". 其用法及含意如下 :
http://blog.csdn.net/wisgood/article/details/8894702
awk程序中可接受下列两种语法:
[a. 语法] awk output 指令 | "Shell 接受的命令"

( 如 : print $1,$2 | "sort -k 1" )

[b. 语法] "Shell 接受的命令" | awk input 指令

( 如 : "ls " | getline)

注 : awk input 指令只有 getline 一个.
awk output 指令有 print, printf() 二个.

*** sed(关键字: 编辑) 以行为单位的文本编辑工具
	sed可以直接修改档案, 不过一般不推荐这么做, 可以分析 standard input
基本工作方式: sed [-nef] '[动作]' [输入文本]
-n : 安静模式, 一般sed用法中, 来自stdin的数据一般会被列出到屏幕上, 如果使用-n参数后, 只有经过sed处理的那一行被列出来.
-e : 多重编辑, 比如你同时又想删除某行, 又想改变其他行, 那么可以用 sed -e '1,5d' -e 's/abc/xxx/g' filename
-f : 首先将 sed的动作写在一个档案内, 然后通过 sed -f scriptfile 就可以直接执行 scriptfile 内的sed动作 (没有实验成功, 不推荐使用)
-i : 直接编辑, 这回就是真的改变文件中的内容了, 别的都只是改变显示. (不推荐使用)
动作:
a 新增, a 后面可以接字符串, 而这个字符串会在新的一行出现. (下一行)
c 取代, c 后面的字符串, 这些字符串可以取代 n1,n2之间的行
d 删除, 后面不接任何东西
i 插入, 后面的字符串, 会在上一行出现
p 打印, 将选择的资料列出, 通常和 sed -n 一起运作 sed -n '3p' 只打印第3行
s 取代, 类似vi中的取代, 1,20s/old/new/g

[line-address]q 退出, 匹配到某行退出, 提高效率

[line-address]r 匹配到的行读取某文件 例如: sed '1r qqq' abc , 注意, 写入的文本是写在了第1行的后边, 也就是第2行

[line-address]w file, 匹配到的行写入某文件  例如: sed -n '/m/w qqq' abc , 从abc中读取带m的行写到qqq文件中, 注意, 这个写入带有覆盖性.


举例:
sed '1d' abc 删除 abc 档案里的第一行, 注意, 这时会显示除了第一行之外的所有行, 因为第一行已经被删除了(实际文件并没有被删除,而只是显示的时候被删除了)
sed -n '1d' abc 什么内容也不显示, 因为经过sed处理的行, 是个删除操作, 所以不现实.
sed '2,$d' abc 删除abc中从第二行到最后一行所有的内容, 注意, $符号正则表达式中表示行末尾, 但是这里并没有说那行末尾, 就会指最后一行末尾, ^开头, 如果没有指定哪行开头, 那么就是第一行开头
sed '$d' abc 只删除了最后一行, 因为并没有指定是那行末尾, 就认为是最后一行末尾
sed '/test/d' abc 文件中所有带 test 的行, 全部删除
sed '/test/a RRRRRRR' abc 将 RRRRRRR 追加到所有的带 test 行的下一行 也有可能通过行 sed '1,5c RRRRRRR' abc
sed '/test/c RRRRRRR' abc 将 RRRRRRR 替换所有带 test 的行, 当然, 这里也可以是通过行来进行替换, 比如 sed '1,5c RRRRRRR' abc

*** grep(关键字: 截取) 文本搜集工具, 结合正则表达式非常强大
主要参数 []
-c : 只输出匹配的行
-I : 不区分大小写
-h : 查询多文件时不显示文件名
-l : 查询多文件时, 只输出包含匹配字符的文件名
-n : 显示匹配的行号及行
-v : 显示不包含匹配文本的所有行(我经常用除去grep本身)
基本工作方式: grep 要匹配的内容 文件名, 例如:
grep 'test' d* 显示所有以d开头的文件中包含test的行
grep 'test' aa bb cc 显示在 aa bb cc 文件中包含test的行
grep '[a-z]\{5}\' aa 显示所有包含字符串至少有5个连续小写字母的串

** xargs , exec
-exec: {}表示命令的参数,即所找到的文件,以 ; 表示 command 命令的结束。\是转义符，
因为分号在命令中还有它用途，所以就用一个\来限定表示这是一个分号而不是表示其它意思。

-ok： 和 -exec 的作用相同，格式也一样，只不过以一种更为安全的模式来执行该参数
所给出的shell给出的这个命令之前，都会给出提示，让用户来确定是否执行。

例子
$find . -name 'core' -type f -exec rm {} \;
find -exec 命令会对每个匹配的文件执行一个单独的rm操作（execute a separate rm for each one）
使用这种方式，如果有100个文件匹配了，那么就需要启100个进程，一个进程处理一个rm命令。

# xargs 要结合管道来完成
格式：find [option] express |xargs command

前提是后面的命令必须支持多参数。
有些命令，比如unzip，就不支持输入多个jar包，所以必须用-exec。
xargs，顾名思义，是对参数进行处理的命令。
它的任务就是将输入行转换成下一个命令的参数列表。
因此上面的find -exec命令可以改写成：

$find . -name 'core' -type f -print | xargs rm

# 比较
$find test/ -type f |xargs echo
test/myfile.name test/files/role_file test/files/install_file

$find test/ -type f -exec echo {} \;
test/myfile.name
test/files/role_file
test/files/install_file

很明显，exec是对每个找到的文件执行一次命令，除非这单个的文件名超过了几k，否则不
会出现命令行超长出报错的问题。

而xargs是把所有找到的文件名一股脑的转给命令。当文件很多时，这些文件名组合成的命
令行参数很容易超长，导致命令出错。

另外， find | xargs 这种组合在处理有空格字符的文件名时也会出错，因为这时执行的命令
已经不知道哪些是分割符、哪些是文件名中的空格！ 而用exec则不会有这个问题。

# 相比之下，也不难看出各自的缺点
1、exec 每处理一个文件或者目录，它都需要启动一次命令，效率不好; 
2、exec 格式麻烦，必须用 {} 做文件的代位符，必须用 \; 作为命令的结束符，书写不便。
3、xargs 不能操作文件名有空格的文件；

综上，如果要使用的命令支持一次处理多个文件，并且也知道这些文件里没有带空格的文件，
那么使用 xargs比较方便; 否则，就要用 exec了。
# xargs -i 等同于 -exec
cat args.txt|xargs -i echo {}

scp getSealPicture.rar zsl@10.11.11.79:/home/zsl/codes/
** patch -Np1 -i ../bzip2-1.0.6-install_docs-1.patch
* 如何处理包含空格和特殊字符的文件名
  包含特殊字符的文件名的例子，并不常见：
#232.txt
#bkf.txt
#bjsd3469.txt
#121nkfd.txt
-2232.txt
-fbjdew.txt
-gi32kj.txt
--321.txt
--bk34.txt
...
一个显而易见的问题是 - 在这个星球上有谁会创建和处理包含井号(#)，分号(;)，破折号(-)或其他特殊字符的文件/文件夹啊！

我和你想的一样，这种文件名确实不常见，不过在你必须得处理这种文件名的时候你的 shell 也不应该出错或罢工。而且技术上来说，Linux 下的一切比如文件夹、驱动器或其他所有的都被当作文件处理。

处理名字包含破折号(-)的文件
创建以破折号(-)开头的文件，比如 -abx.txt。

$ touch -abc.txt
测试输出
touch: invalid option -- 'b'
Try 'touch --help' for more information.
出现上面错误的原因是，shell 把破折号(-)之后的内容认作参数了，而很明显没有这样的参数，所以报错。

要解决这个问题，我们得告诉 Bash shell（是的，这里以及本文后面的大多数例子都是基于 BASH 环境）不要将特殊字符（这里是破折号）后的字符解释为参数。

有两种方法解决这个错误：

$ touch -- -abc.txt     [方法 #1]
$ touch ./-abc.txt      [方法 #2]
你可以通过运行命令 ls 或 ls -l 列出详细信息来检查通过上面两种方式创建的文件。

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 11:05 -abc.txt
要编辑上述文件可以这样：

$ nano -- -abc.txt 
或者 
$ nano ./-abc.txt 
注意：你可以将 nano 替换为任何其他你喜欢的编辑器比如说 vim：

$ vim -- -abc.txt 
或者 
$ vim ./-abc.txt 
如果只是简单地移动文件可以这样：

$ mv -- -abc.txt -a.txt
或者
$ mv -- -a.txt -abc.txt
删除这种文件，可以这样：

$ rm -- -abc.txt
或者
$ rm ./-abc.txt 
如果一个目录下有大量这种名字包含破折号的文件，要一次全部删除的话，可以这样：

$ rm ./-*
重要：

上面讨论的规则可以同样应用于名字中包含任意数量以及任意位置的连接符号的文件。就是说，-a-b-c.txt，ab-c.txt，abc-.txt，等等。

上面讨论的规则可以同样应用于名字中包含任意数量以及任意位置连接符号的文件夹，除了一种情况，在删除一个文件夹的时候你得这样使用rm -rf：

$ rm -rf -- -abc 或者 $ rm -rf ./-abc

处理名字包含井号(#)的文件
符号#在 BASH 里有非常特别的含义。#之后的一切都会被认为是评论，因此会被 BASH 忽略。

通过例子来加深理解：

创建一个名字是 #abc.txt 的文件：

$ touch #abc.txt
测试输出
touch: missing file operand
Try 'touch --help' for more information.
出现上面错误的原因是，BASH 将 #abc.txt 解释为评论而忽略了。所以命令 touch没有收到任何文件作为参数，所以导致这个错误。

要解决这个问题，你可能需要告诉 BASH 不要将 # 解释为评论。

$ touch ./#abc.txt
或者
$ touch '#abc.txt'
检查刚创建的文件：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 12:14 #abc.txt
现在创建名字中除了开头的其他地方包含 # 的文件。

$ touch ./a#bc.txt
$ touch ./abc#.txt    
或者
$ touch 'a#bc.txt'
$ touch 'abc#.txt'
运行 ‘ls -l‘ 来检查：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 12:16 a#bc.txt
-rw-r--r-- 1 avi avi 0 Jun  8 12:16 abc#.txt
如果同时创建两个文件（比如 a 和 #bc）会怎么样：

$ touch a.txt #bc.txt
检查刚创建的文件：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 12:18 a.txt
很明显上面的例子中只创建了文件 a 而文件 #bc 被忽略了。对于上面的情况我们可以这样做，

$ touch a.txt ./#bc.txt
或者
$ touch a.txt '#bc.txt'
检查一下：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 12:20 a.txt
-rw-r--r-- 1 avi avi 0 Jun  8 12:20 #bc.txt
可以这样移动文件：

$ mv ./#bc.txt ./#cd.txt
或者
$ mv '#bc.txt' '#cd.txt'
这样拷贝：

$ cp ./#cd.txt ./#de.txt
或者
$ cp '#cd.txt' '#de.txt'
可以使用你喜欢的编辑器来编辑文件：

$ vi ./#cd.txt
或者
$ vi '#cd.txt'
 
$ nano ./#cd.txt
或者
$ nano '#cd.txt'
这样删除：

$ rm ./#bc.txt 
或者
$ rm '#bc.txt'
要删除所有以井号（#）开头的文件，可以这样：

# rm ./#*
处理名字包含分号(;)的文件
如果你还不知道的话，分号在 BASH 里起到命令分隔的作用，其他 shell 可能也是一样的。分号作为分隔符可以让你一次执行几个命令。你碰到过名字包含分号的文件吗？如果没有的话，这里有例子。

创建一个名字包含分号的文件。

$ touch ;abc.txt
测试输出
touch: missing file operand
Try 'touch --help' for more information.
bash: abc.txt: command not found
出现上面错误的原因是，在运行上面命令的时候 BASH 会把 touch 解释为一个命令但是在分号前没有任何文件参数，所以报告错误。然后报告的另一个错误找不到命令 abc.txt，只是因为在分号后 BASH 会期望另一个新的命令，而 abc.txt 并不是一个命令。

要解决这个问题，我们得告诉 BASH 不要将分号解释为命令分隔符，例如：

$ touch ./';abc.txt'
或者
$ touch ';abc.txt'
注意：我们将文件名用单引号 '' 包含起来。这样可以告诉 BASH 分号 ; 是文件名的一部分而不是命令分隔符。

对名字包含分号的文件和文件夹的其他操作（就是，拷贝、移动、删除）可以直接将名字用单引号包含起来就好了。

处理名字包含其他特殊字符的文件/文件夹
文件名包含加号 (+)
不需要任何特殊处理，按平时的方式做就好了，比如下面测试的文件名。

$ touch +12.txt 
文件名包含美元符 ($)
你需要将文件名用单引号括起来，像处理分号那样的方式。然后就很简单了。

$ touch '$12.txt'
文件名包含百分号 (%)
不需要任何特殊处理，当作一个普通文件就可以了。

$ touch %12.txt
文件名包含星号 (*)
需要用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改。）

$ touch *12.txt
注意：当你需要删除星号开头的文件时，千万不要用类似下面的命令。

$ rm *
或者
$ rm -rf *
而是用这样的命令，(LCTT 译注：此处原文有误，已修改）

$ rm ./'*.txt'
文件名包含叹号 (!)
只要将文件名用单引号括起来，其他的就一样了。

$ touch '!12.txt'
文件名包含小老鼠 (@)
没有什么特别的，可以将名字包含小老鼠的文件当作普通文件。

$ touch '@12.txt'
文件名包含 ^
不需要特殊处理。可以将名字包含 ^ 的文件当作普通文件。

$ touch ^12.txt
文件名包含 (&)
将文件名用单引号括起来，然后就可以操作了。

$ touch '&12.txt'
文件名包含括号 ()
如果文件名包含括号，你需要将文件名用单引号括起来。

$ touch '(12.txt)'
文件名包含花括号 {}
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch '{12.txt}'
文件名包含尖括号 <>
名字包含尖括号的文件需要用单引号括起来。

$ touch '<12.txt>'
文件名包含方括号 [ ]
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch '[12.txt]'
文件名包含下划线 (_)
这个非常普遍，不需要特殊对待。当作普通文件随意处理。

$ touch _12.txt
文件名包含等号 (=)
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch '=12.txt'
处理反斜杠 ()
反斜杠会告诉 shell 忽略后面字符的特殊含义。你必须将文件名用单引号括起来，就像处理分号那样。其他的就没什么了。

$ touch '\12.txt'
包含斜杠的特殊情形
除非你的文件系统有问题，否则你不能创建名字包含斜杠的文件。没办法转义斜杠。

所以如果你能创建类似 ‘/12.txt’ 或者 ‘b/c.txt’ 这样的文件，那要么你的文件系统有问题，或者支持 Unicode，这样你可以创建包含斜杠的文件。只是这样并不是真的斜杠，而是一个看起来像斜杠的 Unicode 字符。

文件名包含问号 (?)
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch '?12.txt'
文件名包含点 (.)
在 Linux 里以点 (.) 开头的文件非常特别，被称为点文件。它们通常是隐藏的配置文件或系统文件。你需要使用 ls 命令的 ‘-a‘ 或 ‘-A‘ 开关来查看这种文件。

创建，编辑，重命名和删除这种文件很直接。

$ touch .12.txt
注意：在 Linux 里你可能碰到名字包含许多点 (.) 的文件。不像其他操作系统，文件名里的点并不意味着分隔名字和扩展后缀。你可以创建名字包含多个点的文件：

$ touch 1.2.3.4.5.6.7.8.9.10.txt
检查一下：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 14:32 1.2.3.4.5.6.7.8.9.10.txt
文件名包含逗号 (,)
你可以在文件名中使用逗号，可以有任意多个而不用特殊对待。就像平时普通名字文件那样处理。

$ touch ,12.txt
或者
$ touch ,12,.txt
文件名包含冒号 (:)
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch ':12.txt'
或者
$ touch ':12:.txt'
文件名包含引号（单引号和双引号）
要在文件名里使用引号，我们需要使用交替规则。例如，如果你需要在文件名里使用单引号，那就用双引号把文件名括起来。而如果你需要在文件名里使用双引号，那就用单引号把文件名括起来。（LCTT 译注：或者如果单引号和双引号混杂的情况，你也可以用反斜杠转义。）

$ touch "15'.txt"
 
以及
 
$ touch '15".txt'
文件名包含波浪号 (~)
Linux 下一些像 emacs 这样的文本编辑器在编辑文件的时候会创建备份文件。这个备份文件的名字是在原文件名后面附加一个波浪号。你可以在文件名任意位置使用波浪号，例如：

$ touch ~1a.txt
或者
$touch 2b~.txt
文件名包含空格
创建名字的字符/单词之间包含空格的文件，比如 “hi my name is avishek.txt”。

最好不要在文件名里使用空格，如果你必须要分隔可读的名字，可以使用下划线或横杠。不过，你还是需要创建这样的文件的话，你可以用反斜杠来转义下一个字符。要创建上面名字的文件可以这样做。

$ touch hi\ my\ name\ is\ avishek.txt
 
hi my name is avishek.txt
我已经尝试覆盖你可能碰到的所有情况。上面大多数测试都在 BASH Shell 里完成，可能在其他 shell 下会有差异。

如果你觉得我遗漏了什么（这很正常也符合人性），请把你的建议发表到下面的评论里。保持联系，多评论。不要走开！求点赞求分享求扩散！

* git & hub: GitHub 积累与分享
  # local git server. 方便使用版本管理功能：比较、备份、还原、共享。
   https://git-scm.com/book/zh/v2
   https://git-scm.com/downloads
   https://man.openbsd.org/sshd
   git clone /home/git/project.git
   git clone ssh://user@host/home/git/project.git
   # git config --global core.editor "vim"
** branch 分支
*** 首先，我们创建dev分支，然后切换到dev分支：
$ git checkout -b dev
Switched to a new branch 'dev'
git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：
$ git branch dev
$ git checkout dev
Switched to branch 'dev'
然后，用git branch命令查看当前分支：

$ git branch
 * dev
  master
git branch命令会列出所有分支，当前分支前面会标一个*号。

然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：
Creating a new branch is quick.
然后提交：
$ git add readme.txt 
$ git commit -m "branch test"
[dev fec145a] branch test
 1 file changed, 1 insertion(+)

现在，dev分支的工作完成，我们就可以切换回master分支：

$ git checkout master
Switched to branch 'master'
切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变

现在，我们把dev分支的工作成果合并到master分支上：

$ git merge dev
Updating d17efd8..fec145a
Fast-forward
 readme.txt |    1 +
 1 file changed, 1 insertion(+)
git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。

注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。

当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。

合并完成后，就可以放心地删除dev分支了：

$ git branch -d dev
Deleted branch dev (was fec145a).
删除后，查看branch，就只剩下master分支了：

$ git branch
 * master

# 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。

*** 在项目中我们需要根据tag创建分支.现将创建步骤总结一下.假设在你的主分支上有一个tag为v1.0,主分支的名字为master.
1.执行:Git origin fetch 获得最新.
2.通过:git branch <new-branch-name> <tag-name> 会根据tag创建新的分支.
例如:git branch newbranch v1.0 . 会以tag v1.0创建新的分支newbranch;
3.可以通过git checkout newbranch 切换到新的分支.
4.通过 git push origin newbranch 把本地创建的分支提交到远程仓库.
现在远程仓库也会有新创建的分支啦.

** 本地使用 git 无需服务器，用于版本管理和比较
git init .
git status
git add .
git commit -m"last op"

** $ git tag
$ git tag -l 'v1.4.2.*'

Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated。）
轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。
而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，
电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。

一般都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。

# 创建一个含附注类型的标签，用 -a （译注：取 annotated 的首字母）指定标签名字：
$ git tag -a v1.4 -m 'my version 1.4'
而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。

# 轻量级标签是一个保存着对应提交对象的校验和信息的文件。
创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可：
$ git tag v1.4-lw

# git checkout v0.21   此时会指向打v0.21标签时的代码状态
先 git clone 整个仓库，然后 git checkout tag_name 就可以取得 tag 对应的代码了。
但是这时候 git 可能会提示你当前处于一个“detached HEAD" 状态，因为 tag 相当于是一个快照，
是不能更改它的代码的，如果要在 tag 代码的基础上做修改，你需要一个分支：
git checkout -b branch_name tag_name
这样会从 tag 创建一个分支，然后就和普通的 git 操作一样了。

** git server and users
git push 推送到远程服务器
** .gitignore
	首先要强调一点，这个文件的完整文件名就是“.gitignore”，注意最前面有个“.”。
	这样没有扩展名的文件在Windows下不太好创建，这里给出win7的创建方法：
	创建一个文件，文件名为：“.gitignore.”，注意前后都有一个点。保存之后系统会自动重命名为“.gitignore”。
	一般来说每个Git项目中都需要一个“.gitignore”文件，这个文件的作用就是告诉Git哪些文件不需要添加到版本管理中。

下面我们看看常用的规则：

/mtk/ 过滤整个文件夹
*.zip 过滤所有.zip文件
/mtk/do.c 过滤某个具体文件

很简单吧，被过滤掉的文件就不会出现在你的GitHub库中了，当然本地库中还有，只是push的时候不会上传。

需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：

!*.zip
!/mtk/one.txt

唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。

为什么要有两种规则呢？想象一个场景：我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理。
那么我们就需要使用：

/mtk/
!/mtk/one.txt

假设我们只有过滤规则没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！

最后需要强调的一点是，如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。

简单来说，出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。
git rm --cached FILENAME
所以大家一定要养成在项目开始就创建.gitignore文件的习惯，否则一旦push，处理起来会非常麻烦。

1、配置语法：
　　以斜杠“/”开头表示目录；
　　以星号“*”通配多个字符；
　　以问号“?”通配单个字符
　　以方括号“[]”包含单个字符的匹配列表；
　　以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；

　　此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；

2、示例：
　　（1）规则：fd1/*
　　　　  说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；
　　（2）规则：/fd1/*
　　　　  说明：忽略根目录下的 /fd1/ 目录的全部内容；
　　（3）规则：
/*
!.gitignore
!/fw/bin/
!/fw/sf/
说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；

# 语法规范
空行或是以#开头的行即注释行将被忽略。
可以在前面添加正斜杠/来避免递归,下面的例子中可以很明白的看出来与下一条的区别。
可以在后面添加正斜杠/来忽略文件夹，例如build/即忽略build文件夹。
可以使用!来否定忽略，即比如在前面用了*.apk，然后使用!a.apk，则这个a.apk不会被忽略。
*用来匹配零个或多个字符，如*.[oa]忽略所有以".o"或".a"结尾，*~忽略所有以~结尾的文件（这种文件通常被许多编辑器标记为临时文件）
[]用来匹配括号内的任一字符，如[abc]，也可以在括号内加连接符，如[0-9]匹配0至9的数
?用来匹配单个字符。
来个栗子：
# 忽略 .a 文件
*.a
# 但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件
!lib.a
# 仅在当前目录下忽略 TODO 文件， 但不包括子目录下的 subdir/TODO
/TODO
# 忽略 build/ 文件夹下的所有文件
build/
# 忽略 doc/notes.txt, 不包括 doc/server/arch.txt
doc/*.txt
# 忽略所有的 .pdf 文件 在 doc/ directory 下的
doc/**/*.pdf


* perl
* vi
** 在需要快速比较和合并少量文件的时候，Vimdiff是最好的选择
启动方法
首先保证系统中的diff命令是可用的。Vim的diff模式是依赖于diff命令的。Vimdiff的基本用法就是：
# vimdiff  FILE_LEFT  FILE_RIGHT
或者
# vim -d  FILE_LEFT  FILE_RIGHT

除了用这种方法启动vim的diff模式之外，我们还可以用分割窗口命令来启动diff模式：
# vim FILE_LEFT
然后在vim的ex模式（也就是"冒号"模式）下输入：
:vertical diffsplit FILE_RIGHT
也可以达到同样的效果。

如果希望交换两个窗口的位置，或者希望改变窗口的分割方式，可以使用下列命令：
1. Ctrl-w K（把当前窗口移到最上边）
2. Ctrl-w H（把当前窗口移到最左边）
3. Ctrl-w J（把当前窗口移到最下边）
4. Ctrl-w L（把当前窗口移到最右边）
其中1和3两个操作会把窗口改成水平分割方式。

光标移动
接下来试试在行间移动光标，可以看到左右两侧的屏幕滚动是同步的。
这是因为"scrollbind"选项被设置了的结果，vim会尽力保证两侧文件的对齐。
如果不想要这个特性，可以设置：
:set noscrollbind

可以使用快捷键在各个差异点之间快速移动。跳转到下一个差异点：
]c
反向跳转是：[c
如果在命令前加上数字的话，可以跳过一个或数个差异点，从而实现跳的更远。
比如如果在位于第一个差异点的行输入"2]c"，将越过下一个差异点，跳转到第三个差异点。

# 上下文的展开和查看
比较和合并文件的时候经常需要结合上下文来确定最终要采取的操作。
Vimdiff 缺省是会把不同之处上下各 6 行的文本都显示出来以供参考。
其他的相同的文本行被自动折叠。如果希望修改缺省的上下文行数，可以这样设置：

:set diffopt=context:3

可以用简单的折叠命令来临时展开被折叠的相同的文本行：
zo （folding open，之所以用z这个字母，是因为它看上去比较像折叠着的纸）
然后可以用下列命令来重新折叠：
zc （folding close）

# 文件合并
文件比较的最终目的之一就是合并，以消除差异。如果希望把一个差异点中当前文件的内容复制到另一个文件里，可以使用命令
dp （diff "put"）

如果希望把另一个文件的内容复制到当前行中，可以使用命令
do (diff "get"，之所以不用dg，是因为dg已经被另一个命令占用了)

如果希望手工修改某一行，可以使用通常的vim操作。如果希望在两个文件之间来回跳转，可以用下列命令序列：
Ctrl-w, w

在修改一个或两个文件之后，vimdiff会试图自动来重新比较文件，来实时反映比较结果。但是也会有处理失败的情况，这个时候需要手工来刷新比较结果：
:diffupdate

如果希望撤销修改，可以和平常用vim编辑一样，直接
<ESC>, u

但是要注意一定要将光标移动到需要撤销修改的文件窗口中。

# 同时操作两个文件

在比较和合并告一段落之后，可以用下列命令对两个文件同时进行操作。比如同时退出：
:qa （quit all）

如果希望保存全部文件：
:wa （write all）

或者是两者的合并命令，保存全部文件，然后退出：
:wqa （write, then quit all）

如果在退出的时候不希望保存任何操作的结果：
:qa! （force to quit all）

** leader 快捷键
长久以来我都是使用 , 做为Leader，直到我意识到我可以使用键盘上更加好用的捷按键：空格键（<Space>）。
let mapleader = "\<Space>"
这个完全颠覆了我的 Vim 操作效率，我现在可以使用双手任何一个大拇指进行操作，同时其它手指可以保持在键盘的主键区。

** 寄存器 reg
一：官方帮助手册
:help registers
:help :registers

二： 寄存器分类
1.无名（unnamed）寄存器：""，缓存最后一次操作内容；

2.数字（numbered）寄存器："0 ～ "9，缓存最近操作内容，复制与删除有别, "0寄存器缓存最近一次复制的内容，"1-"9缓存最近9次删除内容

3.行内删除（small delete）寄存器："-，缓存行内删除内容；

4.具名（named）寄存器："a ～ "z或"A - "0Z，指定时可用；

5.只读（read-only）寄存器：":, "., "%, "#，分别缓存最近命令、最近插入文本、当前文件名、当前交替文件名；

6.表达式（expression）寄存器："=，只读，用于执行表达式命令；

7.选择及拖拽（selection and drop）寄存器："*, "+, "~，存取GUI选择文本，可用于与外部应用交互，使用前提为系统剪切板（clipboard）可用；

8.黑洞（black hole）寄存器："_，不缓存操作内容（干净删除）；

9.模式寄存器（last search pattern）："/，缓存最近的搜索模式。

三：查看寄存器内容
:reg         查看所有寄存器内容
:reg 寄存器名  查看单个寄存器内容   比如 :reg _        :reg *            :reg 1           :reg 9          :reg a 等等

数字寄存器，也是最常用的 从0-9。 如果不指定寄存器的名字，那么删除的内容，vim默认是存到 1 ，复制内容是存到 0 号寄存器。 如果继续删除，那么原来 1 的内容就转到 2，类推，当删除超过9的时候， 原先的 8号数字寄存器就转到9， 原先9的数字寄存器内容就会丢失。

实验1：
先在vim里面输入1-0 10个数字，每个数字一行，接着从0 9 8 7 6 5 4 3 2 依次dd删除，然后:reg查看寄存器，接着yy复制数字1的这行，可以看见"0 寄存器 的值是1

“1 ～ ”9 寄存器依次是 2~0

使用p来粘贴，如果最近一次操作是复制，那么p就会添加 “0 寄存器的内容，如果最近一次操作是删除那么就添加 "1 寄存器的内容 ，如果要粘贴其它数字寄存器的内容，

使用 "?p 来粘贴，比如要粘贴 “2 寄存器里面的，则在vim命令模式下 输入 "2p 就可以取出“2寄存器里面的内容了

其他的寄存器都是通过 "?p 来访问使用的。


具名寄存器（字母寄存器），也就是名称是单个英文字母， "a "b "c ,....,"z ， 使用时，在复制或者删除命令 y 或者 d 时，在前面加上字母寄存器的字母名称就可以了, 或者是直接在删除或者复制命令后 加上字母寄存器的字母 比如  :y n 就是复制当前行到 “n 字母寄存器  :5,10y m 复制5到10行内容到 “m 字母寄存器 

:pu! n  将字母寄存器 “n的内容粘贴到当前行之前 也可以使用 "mP 效果一样

:p n  粘贴字母寄存器 ”n 的内容到当前行的下一行 也可以使用 "np 效果一样

(命令模式下  :y :d :pu 分别是复制 删除 和粘贴

一般模式下 "寄存器名y  “寄存器名d "寄存器名p  代表着复制 删除 和 粘贴 )


实验2：
"ayy  就是复制当前行到 "a 字母寄存器中

 "b3yy 复制当前行和下面2行 到 “b 字母寄存器

“ap 粘贴 “a 字母寄存器的内容

“cd2l 向右删除2个字符 并且把内容存到 字母寄存器 “c 中            “cp 粘贴 ”c 字母寄存器里面的内容

”d3dd 删除当前行和下面2行 并且把内容存到 字母寄存器 “d 中  

“fdf.     删除当前位置到句号  并且把内容存到 字母寄存器 “f 中

“gd'c 删除当前位置到标记c位置 并且把内容存到 字母寄存器 “g 中

同一个字母的大写和小写表示的是同一个寄存器，但是行为会不同，字母寄存器的名称大写时，当使用大写的寄存器进行复制或者删除文本时，原先的字母寄存器中的内容会被保留，刚删除或复制的内容则附加到原来字母寄存器内容的后面。 字母寄存器只有在指定时才被使用。


无名寄存器 ""  保存最近一次复制或删除的文本。就是p命令默认使用的寄存器。

短删除寄存器 "- （The small delete register）。事实上刚删除的文本并不一定被送到数字寄存器，如果删除的文本不含换行符（不足一整句）则文本被送至这个寄存器。如x、d2h这两条命令删除的文本都会被送到这个寄存器。注意下在这条命令虽然删除了一整行的文本但因不含换行符所以也被送到这个寄存器`0d$‘。

只读寄存器  ": ". "% "# 它们分别用来保存最近一次在命令行窗口使用的命令、最近一次插入的文本、当前编辑的文件名、当前的替代文件名。

表达式寄存器 "=

选择与拖放的寄存器"* "+ "~ 在Windows中这几个寄存器就是剪贴板。在Linux中它们也是剪贴板——但这几个寄存器是有所区别的。

黑洞寄存器 "_ 删除操作会影响现有数字寄存器的内容。前一个数字寄存器的值传给后一个数字寄存器，"9的内容被丢弃，新删除的文本则放入"1。这至少有两个直接的影响，一是"9的内容被丢弃；二是寄存器中文本的位置都发生了变化。而复制操作会改变"0的值。如果你不希望删除或复制的操作影响数字寄存器的话就使用这个寄存器。使用这个寄存器进行删除或复制的内容都会被丢弃——这还可以提高一点速度节省一点空间。

搜索式样寄存器 "/ 保存上一次搜索所使用的式样。注意这也包括了s命令中所使用的搜索式样。



寄存器有26个字母寄存器可以使用；可以使用大写字母将文本附加到已有内容后。如果在你关闭文件之前还没想到这将这些内容贴在哪里也没关系，

用`:wviminfo my_viminfo‘命令。下一次编辑时输入`:rviminfo! my_viminfo‘或者在命令行用这个命令运行`gvim -i my_viminfo myfile‘，:reg看寄存器的内容都在的。


四 。寄存器是个变量——特殊的变量，只要在前面加上一个@号就可以用变量的方式访问寄存器。

所以，变量的操作也同样适用于寄存器。

" 给寄存器赋值
let @e="开始\<CR>"
let @E="结束"
echo @e
开始
结束
" 将寄存器作为表达式的一部分
let my_var=@a . @c
" 和
echo @e+4
" 清空寄存器。
" 注意：不能用unlet清除寄存器。
:let @e=""


在编辑窗口与命令窗口间交换内容

编辑窗口的文本可以放进寄存器。搜索式样和上一条Ex命令被放进了只读寄存器"/和":。
已知寄存器的内容可以在贴到编辑窗口。可以在命令窗口作为变量使用。那有没有办法在命令窗口插入寄存器的内容呢？有没有办法在搜索式样中插入寄存器的内容呢？

比如，假设在寄存器e中保存着一个文件名：“这是一个保存在寄存器中的很长的文件名.txt”。而我想使用:w命令保存一个当前编辑文件的副本——使用寄存器e中的那个文件名。如果使用`:w @e‘的话，文件名将是“@e”而不是“这是一个保存在寄存器中的很长的文件名.txt”。这时该怎么办呢？考虑到寄存器也是变量，我们可以使用寄存器的传统办法。

" 方法一。使用:execute命令
" 写入以"e为名的寄存器中
:exe "w " . @e
那搜索呢？如果我们要在搜索式样中使用寄存器的内容呢？对于s命令的搜索式样上面的:exe大法仍然适用，但如果只是普通的搜索操作（在一般模式中按/）呢？我们要用到组合键Ctrl-R，用Vim的写法就是<C-R>。

" 方法二。使用Ctrl-R转义。
" 搜索寄存器e的内容。<Ctrl-R>表示用户在这里按了组合键Ctrl-R——不要直接输入<Ctrl-R>这8个字符。
/<Ctrl-R>e/
使用<C-R>的方式可适用于各种输入的环境中：在插入模式输入时、在命令窗口输入时、在搜索时。在插入模式时要输入寄存器内容并不需要退回到一般模式再使用p指令，可以直接按`<Ctrl-R>e‘当然e可以改成相应的寄存器名。在命令窗口与搜索时也是一样：按Ctrl-R输入寄存器名。

提示：除了一些不接受变量作为参数，不能使用寄存器名称的情况外，还有一些情况也要求插入寄存器的内容。有时我们插入寄存器的内容而不使用寄存器变量是因为我们可能还需要手工对寄存器的内容进行一些编辑。

无名寄存器总是保存着最近一次复制或删除的内容。不带寄存器名地使用p就可以添加该寄存器的内容到当前位置了。但是既然“无名”该怎么在命令窗口使用这个存器呢？又怎么插入无名寄存器的内容呢？答案是使用@"，插入也是一样按Ctrl-R再按输入"就可以了。

现在总结一下：":保存了上一条Ex命令。"/保存了上一条搜索式样。字母寄存器及数字寄存器中可以保存编辑的文本。并且我们也可以在不同的环境中插入寄存器的内容。通过寄存器我们可以方便地在命令窗口编辑窗口以及搜索中交换内容。相对而言一般的变量就没这么方便，你只能在命令行中使用变量也只能是命令行中给变量赋值。

 在buffer之间及程序之间交换内容

寄存器是全局的变量。在Vim中打开的所有文件2，共享这些寄存器。你可以在不同的文件之间交换内容。

通过寄存器"*和"+，Vim可以与其他程序交换信息。在Windows中这两个寄存器是一样的。在Linux中这两个寄存器则有所不同。
:help gui-selections
:help x11-selection

寄存器可以做为宏

跟一般的变量相比寄存器还有一个最大的特点就是寄存器本身可以做为宏使用。如果你有用过一般模式命令q的话就会发现q录制的击键序列就是存在寄存器中的，并且可以直接使用寄存器执行命令。现在做做实验，新建一文档随便输入几行文字。输入：
qeggddq
上面这条命令录制了一个宏并保存到寄存器e中。这个宏的作用是回到第一行并删除该行。现在看一下寄存器的内容：
:reg e
就是你刚才的键盘命令ggdd。要运行刚录制的键盘操作在一般模式输入@e就可以运行了，输入3@e会将前三行删除。
当然你不一定要用q来录制宏——因为寄存器也是变量。
:let @e="/删除本行/^Mdd:w^M"
@e
上面的^M表示的是回车键。可不是输入^再输入M，而是输入Ctrl-V（Windows是Ctrl-Q）再按回车键这时就会出现^M表示这是一个回车键。常见的还有^[表示的是<ESC>键。输入的方法也是一样按Ctrl-V再按Esc键。这样输入控制字符的方式是传统的Vi方法。在Vim中也支持用按键名表示这些控制字符。比如<CR>表示回车键3所以上面的命令也可表示为：
:let @e="/删除本行/\<CR>dd:w\<CR>"
这里一定要用双引号，我们在“脚本”一篇中已经讲到了，在单引号中的字串会被当成普通字串。后面这种表示控制字符的方式与'cpoptions'的设置有关，虽然在默认情况下都是可行的但是建议使用第一种方式。不过为了更好的可读性在教程中我们还是可能使用后面这种方式表示控制字符。
正因为寄存器可以直接执行所以":可以用来执行上一条在命令窗口使用的命令：
:@:
记得最后要按回车执行。当然现在由于命令行的历史功能这种用法没有什么实用价值。

在重定向命令中使用
重定向命令（:redir）是一个较常用的技巧。所有的字母寄存器、@*、无名寄存器（@"）都可以在重定向命令中使用。还是用个例子说明好了：
假设你的小说家朋友寄了一本小说的初稿给你，但显然他没有整理文本的习惯——好消息是他这次竟然没用Word写。在你往下看之前你决定先将文档做适当的整理。使用Vim作这种事当然是小菜一碟，只用了10分钟你就将他的小说整理成一份格式整齐的文档了。

** 标记 mark
利用:marks命令，可以列出所有标记。这其中也包括一些系统内置的特殊标记（Special marks）：

. ——最近编辑的位置
0-9 ——最近使用的文件
∧ ——最近插入的位置
' ——上一次跳转前的位置
" ——上一次退出文件时的位置
[ ——上一次修改的开始处
] ——上一次修改的结尾处

# 命令小结
m ——创建标记
' ——移动到标记的文本行首
` ——移动到标记的光标位置
:marks ——列示所有标记
:delmarks ——删除指定标记
:delmarks! ——删除所有标记

* emacs, evil(vi)
** keys
*** elisp keys
1. clear 多个空格
   M-SPC just-one-space
   M-\ delete-horizontal-space
2. <f12> runs the command repeat,a Lisp function in ‘repeat.el’.
   It is bound to <f12>, C-x z. (repeat REPEAT-ARG)

*** evil keys : vim
1) . evil-repeat Repeat the last editing command
2) <N>C-e/C-y, <E>M-n/M-p
3) <N>y*/p,    <E>M-w, C-k / C-y, M-y yank, yank-pop
  	(setq evil-want-C-i-jump nil) ; don't bind [tab] to evil-jump-forward
	(define-key evil-normal-state-map (kbd "TAB") 'indent-for-tab-command) ;; TAB to indent in normal-state

*** leader keys
(evil-leader/set-leader "<SPC>")
;; (setq evil-leader/non-normal-prefix "M-") ;; [?\\M- ], not [M-SPC]
(setq evil-leader/non-normal-prefix "?\\M-")

(evil-leader/set-key "w" 'save-buffer)
(evil-leader/set-key "f" 'find-file)
(evil-leader/set-key "o" 'other-frame)
(evil-leader/set-key "<SPC>" 'evil-normal-state)

(evil-leader/set-key
  "ml" 'bookmark-bmenu-list
  "mm" 'bookmark-set
  "mb" 'bookmark-jump
  "mh" 'highlight-bookmarks-the-buffer
  "mc" 'highlight-bookmarks-clean)

(evil-leader/set-key
  "h" 'previous-buffer
  "l" 'next-buffer
  "b" 'ido-switch-buffer)
;; "b" 'switch-to-buffer

** 不断进化，且具有强大的进化能力
  https://github.com/lujun9972/emacs-document
  # 在emacs中运行Linux shell命令：M-!
1. 学无止境 elisp
2. 熟能生巧 keys
3. 温故而知新，随Emacs主程序版本一起，更新插件，重构*.el和配置
** 寄存器 register C-xr
   Emacs 寄存器是通用的存储机制，它可以存储很多内容中的一项，
   包括文本、矩形区块、缓冲区中的位置，或者某些其他值或设置。
   每个寄存器都有一个标签，您可以使用单个字符来引用寄存器。
   可以重定义寄存器，但是它一次只能包含一项内容。
   一旦您退出 Emacs，将清空所有的寄存器。

   # 所有的 Emacs 寄存器命令都是以 C-xr 开头的。

键盘输入	功能	描述
C-x r space X	point-to-register	将光标保存到寄存器 X。
C-x r s X	copy-to-register	将区域保存到寄存器 X。
C-x r r X	copy-rectangle-to-register	将选定的矩形区块保存到寄存器 X。
未定义	view-register	查看一个给定的寄存器的内容。
C-x r j X	jump-to-register	将光标移动到寄存器 X 中给定的位置。
C-x r i X	insert-register	在光标处插入寄存器 X 的内容。
** 书签 bookmark C-xr
   Emacs 提供了保存缓冲区中位置的另一种工具
   这些 Emacs 书签的工作方式与寄存器相同，但是它们的标签可以超过一个字符长
   而且它们比寄存器更为持久：如果保存了书签，那么您可以在两个不同的会话之间使用它们
   它们将一直保留下来，直到您删除它们

   要在当前缓冲区中，为您正在访问的文件的当前光标设置一个书签
   可以运行 bookmark-set 功能，它与 C-x r m 进行了绑定。

   bookmarks-bmenu-list 功能可以列出一个由已设置的所有书签组成的菜单
   通过键入 C-x r l 运行该功能

   可以通过直接跳转至某个书签，而无需从书签列表中选择它
   要跳转至某个特定的书签，可以使用 bookmark-jump 功能，C-x r b。
   如果尚未在缓冲区中打开这个带书签的文件，那么这一命令将打开它。

   删除一个书签，键入 C-x bookmark-delete 并按 Enter

   bookmark-save 将所有的书签保存到书签文件 ~/.emac.bmk 中。

   # visual bookmark, highlight bookmark line
 http://www.gnu.org/software/emacs/manual/html_node/elisp/Finding-Overlays.html
 http://raebear.net/comp/emacscolors.html

(progn  (goto-line 462)
(let
     ((overlay-highlight (make-overlay
						  (+ 10 (line-beginning-position))
						  (- (line-end-position) 10))))
  (overlay-put overlay-highlight 'face '(:background "green"))
  (overlay-put overlay-highlight 'line-highlight-overlay-marker t))) (remove-overlays (line-beginning-position) (+ 1 (line-end-position)))

(remove-overlays (point-min) (point-max))
(goto-char 11184)

1. 读取 bookmarks 文件
   bookmark-default-file
   (bookmark-all-names)
   (nth 3 (bookmark-all-names))
   (bookmark-get-bookmark (nth 3 (bookmark-all-names)))
   (bookmark-get-bookmark (car (bookmark-all-names)))
   (bookmark-get-bookmark-record (car (bookmark-all-names)))
   (bookmark-get-position (nth 3 (bookmark-all-names)))
   (bookmark-get-handler (car (bookmark-all-names)))
2. 查看当前文件是否有书签
   (buffer-file-name)
   (bookmark-get-filename (car (bookmark-all-names)))
 (expand-file-name "~/project/sspdf/src/ci.hpp")
   (file-truename )
3. 调用高亮书签的函数
(highlight-bookmarks-the-buffer)
(mapcar
 (lambda (bmk)
   (if (string= (buffer-file-name) (bookmark-get-filename bmk))
	   (let ((pos (bookmark-get-position (nth 3 (bookmark-all-names))))
	   hlpos
			 )
		 (setq hlpos (make-overlay pos (+ 3 pos)))
		 (prin1 hlpos)
		 (overlay-put hlpos 'face '(:background "green"))
		 (overlay-put hlpos 'line-highlight-overlay-marker t))
	 (message bmk)
	 ))
	 (bookmark-all-names))
   
(defun highlight-bookmarks-the-buffer ()
    (mapcar ...)
)

4. 如果一打开就高亮，则需要buffer hook

** 编码
1.查看当前buffer的编码：M-x describe-coding-system
2.列出所有编码：C-x <RET> r <TAB>
3.以指定编码重读当前buffer：C-x <RET> r utf-8，（revert-buffer-with-coding-system）
4.改变当前buffer的编码：C-x <RET> f utf-8，（set-buffer-file-coding-system）
5.设定下一步操作的编码格式：C-x <RET> c，（universal-coding-system-argument）

** Evil 将 Emacs变为Vim
   https://github.com/emacs-evil/evil
   Evil-mode 的开发者公开宣称 Evil-mode 应该与 Vim 一模一样, 任何不一样的地方都视为BUG.
   然后有一些相熟的资深Vim党也开始用这个Evil-mode,于是我知道了,这个mode确实很棒.
   https://github.com/lujun9972/emacs-document

   Emacs默认文本对象能力不强, 有了evil的拓展 C-o di" 轻轻松松搞定~
   http://www.kuqin.com/shuoit/20150727/347223.html
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (package-initialize)
Then:
  M-x package-refresh-contents
  M-x package-install RET evil

 (require 'evil)
 (evil-mode 1)

 Thanks Evil, 把 Emacs 打造成了理想的 “Vim 化的 Emacs Editor” 
 然后还在 .bashrc 里添加了alias vi='emacs -nw'， 不要纠结是 Vim, Emacs 还是 Evil，他只是我的编辑器。

 默认配置完全模拟 Vim，除了用 Ctr-z 来切换模式。
 调整成在 Insert 模式下恢复 Emacs 键绑定，用 Esc 退到 Normal 模式。
 
 (setq evil-toggle-key "") ; remove default evil-toggle-key C-z, manually setup later
 (setq evil-want-C-i-jump nil) ; don't bind [tab] to evil-jump-forward

 (setcdr evil-insert-state-map nil) ;; remove all keybindings from insert-state keymap, use emacs-state when editing
 (define-key evil-insert-state-map [escape] 'evil-normal-state) ;; ESC to switch back normal-state
 (define-key evil-normal-state-map (kbd "TAB") 'indent-for-tab-command) ;; TAB to indent in normal-state

 ;; Use j/k to move one visual line insted of gj/gk
 (define-key evil-normal-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
 (define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
 (define-key evil-motion-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
 (define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
 
** leader 可绑定 Emacs 命令
# try
(require 'evil-leader)
(setq evil-leader/in-all-states t)
(evil-mode nil)
(global-evil-leader-mode 1)
(evil-mode 1)

(evil-leader/set-key "f" 'find-file)
;; "b" 'switch-to-buffer
;; "k" 'kill-buffer)
(evil-leader/set-key
  "l" 'bookmark-bmenu-list
  "m" 'bookmark-set
  "b" 'bookmark-jump)

** 复制粘贴
1、在网上广为流传的一种让emacs和系统剪切板共享的方法是在.emacs文件中加入

(setq x-select-enable-clipboard t)
这种方法仅对图形化emacs有效，如果用 emacs -nw 命令打开emacs的话，在命令行中是无效的，因为在命令行下没有权限访问 X 的剪切板（http://unix.stackexchange.com/questions/72605/emacs-copy-and-paste）。

2、正因为第1点，所以网上同时流传着另一种方法：

;;start 设置剪切板共享 

(defun copy-from-osx () 

(shell-command-to-string "pbpaste")) 

(defun paste-to-osx (text &optional push) 

(let ((process-connection-type nil)) 

(let ((proc (start-process"pbcopy" "*Messages*" "pbcopy"))) 

(process-send-string proc text) 

(process-send-eof proc)))) 

(setq interprogram-cut-function 'paste-to-osx) 

(setq interprogram-paste-function 'copy-from-osx) 

;;end 设置剪切板共享 

这种方法确实可用，但是里面的pbpaste和pbcopy命令根本不是Linux下的，而是mac下的。所以在linux下应该找到等效的命令替换它们。

3、linux下的剪切板操作命令

找到了两种：xclip和xsel

这两个命令linux不自带，需要安装。两种命令的具体使用方法不做介绍，总之nicek在网上找到了一个适用于linux下的配置（http://hugoheden.wordpress.com/2009/03/08/copypaste-with-emacs-in-terminal/）：

;; http://hugoheden.wordpress.com/2009/03/08/copypaste-with-emacs-in-terminal/
;; I prefer using the "clipboard" selection (the one the
;; typically is used by c-c/c-v) before the primary selection
;; (that uses mouse-select/middle-button-click)
(setq x-select-enable-clipboard t)

;; If emacs is run in a terminal, the clipboard- functions have no
;; effect. Instead, we use of xsel, see
;; http://www.vergenet.net/~conrad/software/xsel/ -- "a command-line
;; program for getting and setting the contents of the X selection"
(unless window-system
 (when (getenv "DISPLAY")
  ;; Callback for when user cuts
  (defun xsel-cut-function (text &optional push)
    ;; Insert text to temp-buffer, and "send" content to xsel stdin
    (with-temp-buffer
      (insert text)
      ;; I prefer using the "clipboard" selection (the one the
      ;; typically is used by c-c/c-v) before the primary selection
      ;; (that uses mouse-select/middle-button-click)
      (call-process-region (point-min) (point-max) "xsel" nil 0 nil "--clipboard" "--input")))
  ;; Call back for when user pastes
  (defun xsel-paste-function()
    ;; Find out what is current selection by xsel. If it is different
    ;; from the top of the kill-ring (car kill-ring), then return
    ;; it. Else, nil is returned, so whatever is in the top of the
    ;; kill-ring will be used.
    (let ((xsel-output (shell-command-to-string "xsel --clipboard --output")))
      (unless (string= (car kill-ring) xsel-output)
	xsel-output )))
  ;; Attach callbacks to hooks
  (setq interprogram-cut-function 'xsel-cut-function)
  (setq interprogram-paste-function 'xsel-paste-function)
  ;; Idea from
  ;; http://shreevatsa.wordpress.com/2006/10/22/emacs-copypaste-and-x/
  ;; http://www.mail-archive.com/help-gnu-emacs@gnu.org/msg03577.html
 ))
** elisp
You can evaluate an expression and see its result in any of several ways, including:
+ Put your cursor after the last close-paren and type C-j (control + j)
+ Put your cursor inside the expression and type M-C-x (alt + control + x)
+ Put your cursor after the last close-paren and type C-x C-e

*** Lexical Stuff
Comments:
Single-line only. They start with a semicolon:
(blah blah blah)   ;  I am a comment
(message "Hello World!") ; elisp first

Characters:
?x is the syntax for an ASCII character: ? followed by the character.
e.g.: ?a is ascii 97 ('a'), ? (that is, question-mark space) is ascii 32 (' ').
Some need to be escaped, such as ?\(, ?\) and ?\\
Emacs 22+ has unicode support. Out of scope for this primer.
`C-x 8 RET'

Numbers:
Integers are 29 bits of precision (not the usual 32). -32, 0, 157, etc.
Binary:         start with #b, e.g. #b10010110
Octal:          #o[0-7]+, e.g. #o377
Hexadecimal:    start with #x, e.g. #xabcd, #xDEADBEE
Floating-point: the usual. -10.005, 0.0, 3.14159265 (64 bits of precision.)
Scientific:     the usual. 6.02e23, 5e-10
The variables most-positive-fixnum and most-negative-fixnum are the largest
and smallest integers representable in Emacs Lisp without bignum support.

Strings:
Double-quoted only.
"He's said: \"Emacs Rules\" one time too many."

You can embed newlines in strings, like so:
"Oh Argentina!
Your little tin of pink meat
Soars o'er the Pampas"

Booleans:
The symbol t (just a letter 't' by itself) is true.
The symbol nil is false (and also means null).
In Emacs Lisp, nil is the only false value;
everything else evalutes to true in a boolean context,
including empty strings, zero, the symbol 'false, and empty vectors.
An empty list, '(), is the same thing as nil.

Arrays:
Elisp has fixed-sized arrays called "vectors".
[-2 0 2 4 6 8 10]
["No" "Sir" "I" "am" "a" "real" "horse"]
["hi" 22 120 89.6 2748 [3 "a"]]
Note that you do not (and cannot) use commas to separate the elements; use whitespace.
Vectors can have mixed-type elements, and can be nested.
You usually use the function make-vector to create them,
since literal vectors are singletons, which can be surprising.
# 操作
(setq xyz ["str" 3.14 [() ?d] 'some])
(aref xyz 2)
(aset xyz 0 "zsl")
(aref xyz 0)

Lists:
Lisp makes heavy use of linked lists, so there's lexical syntax for them.
Anything in parentheses is a list, but unless you quote it, it will be evaluated as a function call.
There are various ways to quote things in Lisp:
(quote (1 2 3)) ; produces the list (1 2 3) with no list-element evaluation
'(1 2 3)  ; apostrophe is shorthand for (quote (...))
          ; note that it goes _outside_ the left-paren
(list 1 (+ 1 1) 3) ; also produces (1 2 3), since it evaluates the elements first
`(1 ,(+ 1 1) 3)  ; another (1 2 3) via a template system called "backquote"
There's a lot more that could be said about lists, but other people have already said it.

Pairs:
You can set the head and tail (also known as car and cdr) fields of a lisp link-list node struct
(also known as a cons cell) directly, using it as a 2-element untyped struct.
The syntax is (head-value . tail-value), and you have to quote it (see above).

A common lookup-table data-structure for very small data sets is an associative list (known as an alist).
It's just a list of dotted pairs, like so:
'( (apple . "red")
   (banana . "yellow")
   (orange . "orange") )
Emacs Lisp has built-in hashtables, bit-vectors, and miscellaneous other data structures,
but there's no syntax for them; you create them with function calls.

*** Operators
  Some operations that are typically operators in other languages are function calls in elisp.
Equality:
Numeric equality: (= 2 (+ 1 1)) Single-equal. Yields t or nil. Works for floats too.
Not-numerically-equal: (/= 2 3) I know, it looks like assign-divide-equal. But it's not.

Value equality: (eq 'foo 2) Like Java ==. Works for ints, symbols, interned strings, and object references.
 Use eql for floating-point numbers (or just =).

Deep (structural) equality: use equal, as in:
(equal '(1 2 (3 4)) (list 1 2 (list 3 (* 2 2))))  ; true

The equal function is like Java's Object.equals(). Works for lists, vectors, strings, and just about anything else.

String
Strings don't have any operators, but there are lots of string functions. Some common ones:
(concat "foo" "bar" "baz")  ; yields "foobarbaz"
(string= "foo" "baz")  ; yields nil (false).  Can also use equal.
(substring "foobar" 0 3) ; yields "foo"
(upcase "foobar")  ; yields "FOOBAR"

Do M-x apropos RET \bstring\b RET to see a list of functions related to strings.
(apropos "string")

Arithmetic

Easiest to show as a table...
| C/Java/JS Operator | Emacs Lisp                         | Example         |                       Result |
| +                  | +                                  | (+ 1 2 3 4 5)   |                           15 |
| -                  | -                                  | (- 6 2 3)       |                            1 |
| *                  | *                                  | (* 2 -1 4.2)    |                         -8.4 |
| /                  | /                                  | (/ 10 3)        | 3 (use floats for float div) |
| %                  | %                                  | (% 10 3)        |                            1 |
| <<                 | lsh                                | (lsh 1 5)       |                           32 |
| >>                 | ash (negative amount)              | (ash -32 -4)    |                           -2 |
| >>>                | lsh (negative amount)              | (lsh 32 -4)     |                            2 |
| ++                 | incf (requires 'cl library)        | (incf x 6)      |                          x+6 |
| --                 | decf (ditto)                       | (decf x 5)      |                          x-5 |
| ? : (ternary)      | (if test-expr then-expr else-expr) | (if t 3 4)      |                            3 |
| &&                 | and                                | (and t t t nil) |                          nil |

|| or  (or nil nil nil t)  t
! (logical-not)	not	(not 3)	nil
~ (bit-not)	lognot	(lognot #b1001)	-10
^ (bit-xor)	logxor	(logxor 5 3)	6
& (bit-and)	logand	(logand 1 3)	1
| (bit-or)	logior	(logior 1 3)	3
<	<	(< 5 3)	nil
>	>	(> 5 3)	t
<=	<=	(<= 3 3)	t
>=	>=	(>= 5 3)	t
. (field access)	see setf below	n/a	n/a
[] (array access)	aref/aset	(aref [2 4 6] 1)	4

*** Statements
This section has some recipes for simple Java-like statements.
It's not comprehensive – just some recipes to get you going.

if/else
Case 1: no else clause: (if test-expr expr)
Example:
(if (>= 3 2)
  (message "hello there"))

Case 2: else clause: (if test-expr then-expr else-expr)
(if (today-is-friday)         ; test-expr
    (message "yay, friday")   ; then-expr
  (message "boo, other day")) ; else-expr

If you need multiple expressions (statements) in the then-expr,
you wrap them with a call to progn, which is like curly-braces in C or Java:
(if (zerop 0)
    (progn
      (do-something)
      (do-something-else)
      (etc-etc-etc)))

You don't need the progn around the else-expr
-– everything after the then-expr is considered to be part of the else-expr. Hence:
(if (today-is-friday)
    (message "yay, friday")
  (message "not friday!")
  (non-friday-stuff)
  (more-non-friday-stuff))

Case 3: else-if clause: Just nest 'em. Or use cond (see below).
(if 'sunday
    (message "sunday!")      ; then-expr
  (if 'saturday              ; else-if
      (message "saturday!")  ; next then-expr
    (message ("weekday!")))) ; final else

Case 4: no else-if, multiple body expressions – use when:
If you don't have an else-clause, then you can use the when macro, which provides an implicit progn:
(when (> 5 1)
  (blah)
  (blah-blah)
  (blah blah blah))

You can also use unless, which is like when but inverts the sense of the test:
(unless (weekend-p)
  (message "another day at work")
  (get-back-to-work))

switch
Elisp has two versions of the classic switch statement: cond and case.

Elisp does not have a table-lookup optimization for switch,
so cond and case are just syntax for nested if-then-else clauses.
However, if you have more than one level of nesting, it looks a lot nicer than if expressions.
The syntax is:
(cond
  (test-1
    do-stuff-1)
  (test-2
    do-stuff-2)
  ...
  (t
    do-default-stuff))

The do-stuff parts can be any number of statements, and don't need to be wrapped with a progn block.

Unlike classic switch, cond can handle any test expression (it just checks them in order), not just numbers.
The downside is that it doesn't have any special-casing for numbers, so you have to compare them to something.
Here's one that does string compares:
(cond
 ((equal value "foo")  ; case #1 – notice it's a function call to `equal' so it's in parens
  (message "got foo")  ; action 1
  (+ 2 2))             ; return value for case 1
 ((equal value "bar")  ; case #2 – also a function call (to `+')
  nil)                 ; return value for case 2
 (t                    ; default case – not a function call, just literal true
  'hello))             ; return symbol 'hello

The final t default clause is optional. The first matching clause is executed,
and the result of the entire cond expression is the result of the last expression in the matching clause.

The 'cl (Common Lisp) package bundled with Emacs provides case, 
which works if you're comparing numbers or symbols, 
so in a sense it works more like standard switch. Example:
(case 12
  (5 "five")
  (1 "one")
  (12 "twelve")
  (otherwise
   "I only know five, one and twelve."))  ; result:  "twelve"

With case you can use either t or otherwise for the default case, but it must come last.
It's cleaner to use case when you can get away with it, but cond is more general.

while
Elisp has a relatively normal while function: (while test body-forms)
Example, which you can evaluate in your *scratch* buffer:
(setq x 10
      total 0)
(while (plusp x)  ; while x is positive
  (message (int-to-string x))
  (incf total x)  ; add x to total
  (decf x))       ; subtract 1 from x

First we set two global variables, x=10 and total=0, then run the loop.
Then we can evaluate the expression total to see that its value is 55 (the sum of the numbers 1 to 10).

*** local variables
You declare function local variables with the let form.
The basic syntax is (let var-decl var-decl)
(let ((name1 value1)
      (name2 value2)
      name3
      name4
      (name5 value5)
      name6
      ...))
Each var-decl is either a single name, or (name initial-value).
You can mix initialized and uninitialized values in any order.
Uninitialized variables get the initial value nil.

You can have multiple let clauses in a function.
Code written for performance often collects all declarations into a single let at the top,
since it's a bit faster that way. Typically you should write your code for clarity first.

*** 学习
	http://www.woola.net/detail/2016-08-18-elisp.html

*** 补充，数组
   _____________________________________________
   |                                             |
   |          Sequence                           |
   |  ______   ________________________________  |
   | |      | |                                | |
   | | List | |             Array              | |
   | |      | |    ________       ________     | |
   | |______| |   |        |     |        |    | |
   |          |   | Vector |     | String |    | |
   |          |   |________|     |________|    | |
   |          |  ____________   _____________  | |
   |          | |            | |             | | |
   |          | | Char-table | | Bool-vector | | |
   |          | |____________| |_____________| | |
   |          |________________________________| |
   |_____________________________________________|

** Ivy 只完成一件事，以及。。。
   https://github.com/lujun9972/emacs-document/blob/master/advertisement/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E4%BB%8EVim%E8%BF%81%E7%A7%BB%E5%88%B0Emacs+Evil.org
   Ivy 为实现最小化，简单化，可定制化，可发现化而努力.
   这四个形容词告诉我们很多Helm 和Ivy 这两个工具间不同的设计理念。

   在写这篇文章的时候，Ivy 只有大概3400行代码，为Ivy 所打造的生态系统：即Swipter 和 Counsel 也只有7500 行代码
   git clone https://github.com/abo-abo/swiper.git
   cd swiper
   ## Only ivy ?
   cat ivy.el | wc -l
   # => 3442
   
   ## count lines of code into the whole swiper ecosystem
   cat *.el | wc -l
   # => 7526

** title full file name
PROMPT_COMMAND is issued before a prompt is set based on the PS1 variable.
 Probably you have some character sequence in PS1 which sets your windows title.

 You may invoke unset PS1 or set it to some other value:

export PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '

Alternatively you can set window title in your PS1 variable:

export PS1='\[\e]0;myWindowTitle\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$'

case $TERM in
  (xterm*) set_title='\[\e]0;\u@\h: \w\a\]';;
  (*) set_title=
esac
PS1=$set_title'\[\e[0;36m\]\T \[\e[1;30m\]\[\e[0;34m\]\u@\H\[\e[1;30m\] \[\e[0;32m\]\[\e[1;37m\]\w\[\e[0;37m\] \$ '

** 扩展推荐
   https://www.zhihu.com/question/21943533/answer/22145491
   company 取代auto-complete,更新很频繁
   yasnippet 代码模板,关键是可内嵌lisp代码执行，太强悍了!接下来唯一的限制就是你的想象力了
   js2-mode javascript开发神器(sublime之流和它根本不是一个数量级的)
   evil-mode 把emacs变成vim，基本vim有的它都有了比如text object，最酷的是可以写lisp自定义text object
   evil-leader 很简单的一个plugin,但是用好的话,让你效率成倍提升.
   evil-matchit 在成对的tag跳来跳去, vim的matchit移植版但更强大(我写的)
   evil-nerd-commenter 按行注释代码, nerd-comment的移植版(我写的)
   helmweb-mode 通吃html所有相关
   windows-numbering.el 子窗口跳转的终极方案,用过所有的编辑器,没有比这个好的了.
   smex 不用再记快捷键了
   # ====补充===
   我先入为主地认为提问者指的是需要安装的第三方扩展,Emacs自带的扩展我补充一下：
   org-mode gtd工具,神级别的软件,和git,vim,emacs是一个档次的
   winner-mode undo窗口layout很有用
   gnus 让我又爱又恨,Emacs其他插件太牛逼, 和yasnippet结合用,和company-mode,和evil等等,所以gnus要伴我终生了.
   ido 类似于helm，和helm各有千秋我都用,五五开,不过helm有个让我爱死的设置,可以选择何时使用ido,helm或者两者都不用.
   # 开源真的不错呃,世界级高手都是惺惺相惜的.不像那些专有软件,菜鸟开发,即使是同一个公司,还要互相往死里掐.
   imenu 显示当前文件函数列表,可以直接跳转到那去,完全可配置,支持所有语言flymake 实时语法检查,通吃所有语言
   flyspell 拼写检查,爱死了,是我见过的所有拼写检查最强大,如果你知道如何配置.
   # ====再补充===
   也许最好的插件就是Lisp语言本身,强大,简单易学,其语法看似诡异,于是自动过滤了菜鸟.
   我的另一个诀窍就是一旦发觉一个好的插件,立即调查原作者,
   务必把他所有开发的使用的工具调查清楚.
   比如mooz维护的的js2-mode让我爱不释手,于是我调查他开发的其他工具,
   keysnail - firefox模拟成Emacs,我用过的同类软件中最好的,细节无可挑剔
   percol - python开发的命令行工具,天才的作品,我现在的工作流主要就靠它,
   没有它我效率要大大降低.

** compile el -> elc
byte-compile-file
byte-recompile-file

** eww 内置浏览器
   http://www.gnu.org/software/emacs/manual/html_node/eww/Basics.html
   EWW, 是 Emacs Web Wowser 的缩写(下边也写作 eww), Wowser 直译是”令人印象深刻的事物”的意思.
   是 2013 年出现, Emacs 24.4 开始内置的文本型浏览器.

   不同于传统的 Emacs 常见浏览器方案 w3m 需要外部工具支持, eww 不需要外部工具支持.
   另外不支持 js 以及外部引入 css , 损失了页面效果的同时, 也减少了很多 http 请求, 加载速度非常快.

   # 基本使用
   M-x eww ENTER emacsist.com 即可访问 Emacs 爱好者站点 Emacsist.com.
   打开网页以后, 显示界面上一般按单个字母即可进行操作, 比如 q 为退出, 也支持简单的书签和浏览历史等功能,
   如果当前网页用 eww 查看起来实在糟糕, 则可以用按 & 调用 eww-browse-with-external-browser 的配置在外部浏览器打开当前页面.
   更详细的操作指引可以 C-h m 查看.

   默认配置下, 如果 M-x eww 回车后输入的内容被检测出来是网址,自动打开, 否则会调用 DuckDuckGo 进行搜索.
   前文的 eww-search-preifx 配置即为修改默认搜索方式. 要打开本地文件用 file:// 开头或者 M-x eww-open-file.

* Makefile

* xwindow 和 字符界面切换
  # 未配置的字符界面，不支持中文。
** 一般有 ALT+CTRL+F1----F6为字符终端（字符界面），ALT+CTRL+F7为图形界面。
   不同的发行版本可能有一些差别，但切换方法都是一样的。

  1、按ALT+CTRL+F1切换到字符界面（Linux实体机）
  如果是VMware虚拟机安装的linux系统，则切换到字符界面的时候需要以下操作
  
  按下ALT+CTRL+SPACE(空格)，ALT+CTRL不松开，再按F1。这样就可以切换到字符界面了。
  
  2、按ALT+CTRL+F7切换到图形界面（Linux实体机）
  
  如果是VMware虚拟机安装的Linux系统，则切换到图形界面的时候需要以下操作
  
  按下ALT+CTRL+SPACE(空格)，ALT+CTRL不松开，再按F7。这样就可以切换到图形界面了。
    
  如果想 Ubuntu 在每次启动到 command prompt ，可以输入以下指令:
  
  $echo “false” | sudo tee /etc/X11/default-display-manager
  
  当下次开机时，就会以命令行模式启动（text模式，字符界面登录），如果想变回图形界面启动（X windows启动），可以輸入:
  
  $echo “/usr/sbin/gdm” | sudo tee /etc/X11/default-display-manager
  
  如果在Ubuntn以命令行模式启动，在字符终端想回到图形界面的话只需以下命令:
  $startx

** xterm/uxterm
   XTerm是一个X Window System上的终端模拟器，用来提供多个独立的SHELL输入输出。
   虚拟终端Xterm是X11标准指定的虚拟终端,历史非常悠久。
   Xterm的缺点:Xterm不支持中文。不过我们可以用Xterm的变种UXterm。
   # xterm 的所有相关设置都在一个名叫 .Xdefaults 的配置文件中
** 新终端： Tilda， F1一键呼出的终端。
** 添加完字体后, 可以用 xlsfonts 命令检查一下是否添加成功


* tools
** 快速使用http方式共享目录
   #进入需要共享的目录后运行: 
   python -m SimpleHTTPServer
   #其它电脑使用http://ip:8000 来访问
   #自定义端口为8080: 
   python -m SimpleHTTPServer 8080

* 安装谷歌浏览器，只需要三行代码： 
打开终端，输入 
cd /tmp 
对于谷歌Chrome32位版本，使用如下链接：
wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb

对于64位版本可以使用如下链接下载：
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 
下载完后，运行如下命令安装。

sudo dpkg -i google-chrome*; sudo apt-get -f install 


* 使用 so 中的类，具体的做法是：
1. 准备一份头文件，加入一个纯虚父类ABase，并声明createA,releaseA；
2. 在生成A.so的实现源码中，写业务类AHello，继承ABase，并导出上面提到的两个函数createA,releaseA；
3. 需要使用A.so的代码，使用dlopen打开so文件,dlsym导入createA,releaseA, 调用createA返回ABase指针类型的实际是AHello类型的实例，便可以使用这个AHello类实例了；
4. 调用raleaseA释放AHello实例。

注意：
1. 基类是纯虚类，不然编译器怎么在编译的时候知道AHello的实现在哪里？
2. 函数导入出需要加上extern “C”防止导出名字被修改。

class shape{ public:
   virtual void draw()=0;
};
class circle : public shape { public:
   void draw();
}

// the class factories
extern "C" shape* create() {
    return new circle;
}
extern "C" void destroy(shape* p) {
    delete p;
}


* libtool link warning xxx was moved.
  打开 xxx.la 查看 libdir 的路径是否正确？

* so 相关
  LD_LIBRARY_PATH=/home/zsl/codes/sursen/sep4
  export LD_LIBRARY_PATH
  # 上面的 = 两边不可以有空格

  使用ldd -r xxx.so或者 nm -A xxx.so等命令，查看so有哪些符号未定义的。

  使用 ldd -u demo 查看不需要链接的so
 使用 -Wl,--as-needed 编译选项
# g++ -Wl,--as-needed -o demo -lz -lm -lrt main.cpp
# ldd demo

* 各种发行版
** Centos下安装c++编译环境
# yum install gcc-c++
yum groupinstall "Development Tools" "Server Platform Development" -y
