* 每天留点时间磨刀：从总体审视、学习或巩固深化、熟能生巧。
 # emacs, notes.org
 # git
 # Vipassana
* 开源世界 http://docs.huihoo.com/open-source/guide/
* MinGW: Minimalist GNUfor Windows。
   它是一个可自由使用和自由发布的Windows特定头文件和使用GNU工具集导入库的集合，
   允许你在GNU/Linux和Windows平台生成本地的Windows程序,
   而不需要第三方C运行时（C Runtime）库。
 

* users
** 用户和组的概念
1. 用户
   用户是能够获取系统资源的权限的集合.
2. 用户组的分类:
   a. 管理员 root  :具有使用系统所有权限的用户,其UID 为0.
   b. 普通用户  : 即一般用户,其使用系统的权限受限,其UID为500-60000之间.
   c. 系统用户 :保障系统运行的用户,一般不提供密码登录系统,其UID为1-499之间.
 
3. 与用户有关的文件/etc/passwd，/etc/shadow
   a. /etc/passwd文件：
      其格式：account：password：UID:GID:GECOS:diretory:shell
      account: 用户名或帐号
      password ：用户密码占位符
      UID：用户的ID号
      GID：用户所在组的ID号
      GECOS:用户的详细信息（如姓名，年龄，电话等）
      diretory：用户所的家目录
      shell：用户所在的编程环境
   b. /etc/shadow
      其格式：account：password：最近更改密码的日期：密码不可更该的天数：密码需要重新更改的天数：密码更改前的警告期限：密码过期的宽限时间：帐号失效日期：保留
4. 用户组
   用户组分类;
   a. 普通用户组:可以加入多个用户
   b. 系统组:一般加入一些系统用户
   c. 私有组(也称基本组):当创建用户时,如果没有为其指明所属组,则就为其定义一个私有的用户组,起名称与用户名同名.
注:私有组可以变成普通用户组,当把其他用户加入到该组中,则其就变成了普通组
5. 组是权限的容器
   如普通用户 a,b,c 所属组grp,则它们会继承组grp的权限
 
6. 与组有关的文件:/etc/group，/etc/gshadow
    /etc/group文件： 其格式:group_name:passwoerd:GID:user_list
     group_name:组名
     passwoerd:组密码
     GID:组的ID号
     user_list：以group_name为附加组的用户列表
7. 修改用户及用户组的命令：useradd，usermod， groupdd，userdel
   a．增加用户 ：useradd [options] username
      options：
                   1．-u ：UID
                   2．-g ：GID
                   3．-d ：指定用户家目录，默认是/home/username
                   4．-s ：指定用户所在的shell环境
                   5．-G：指定用户的附加组
       例如增加一用户wendy UID为1888 家目录/home/oracle，shell为/bin/sh
            #useradd –u 1888 –d /home/oracle –s /bin/sh wendy
    b．修改用户：usermod  [options] username
            options：
                   1．-u ：UID
                   2．-g ：GID
                   3．-d ：指定用户家目录，默认是/home/username
                         -m 与-b 一起用表示把用户家目录的内容也移走
                   4．-s ：指定用户所在的shell环境
                   5．-G：指定用户的附加组
 
       例如修改用户wendy UID为1000 家目录/oracle，shell为/bin/bash
          #usermod –u 1000 –d  /oracle –s /bin/bash -m wendy
          #usermod -G git,user steven #把steven同时加入git组和user组 
     c．增加用户组：groupadd   [options] groupname
           options
                   1．-g ：GID
        例如增加用户组grp UID为1001
          #groupadd –g 1001 grp
     d．删除用户：userdel   [options]username
            options
              1．-r ：连同家目录一起删除
       例如删除用户wendy及家目录
           #userdel –r wendy
** 开发环境：git emacs gcc qmake sshd
** useradd
1.作用
useradd命令用来建立用户帐号和创建用户的起始目录，使用权限是终极用户。
2.格式
useradd [－d home] [－s shell] [－c comment] [－m [－k template]] [－f inactive] [－e expire ] [－p passwd] [－r] name
3.主要参数
－g：指定用户所属的起始群组。
－m：自动建立用户的登入目录。
－s：指定用户登入后所使用的shell。
－c：加上备注文字，备注文字保存在passwd的备注栏中。 
－d：指定用户登入时的启始目录。
－D：变更预设值。
－e：指定账号的有效期限，缺省表示永久有效。
－f：指定在密码过期后多少天即关闭该账号。
－G：指定用户所属的附加群组。
－M：不要自动建立用户的登入目录。
－n：取消建立以用户名称为名的群组。
－r：建立系统账号。
－u：指定用户ID号。
4.说明
useradd可用来建立用户账号，他和adduser命令是相同的。账号建好之后，再用passwd设定账号的密码。使用useradd命令所建立的账号，实际上是保存在/etc/passwd文本文件中。
5.应用实例
建立一个新用户账户，并设置ID：
＃useradd david -u 544
需要说明的是，设定ID值时尽量要大于500，以免冲突。因为Linux安装后会建立一些特别用户，一般0到499之间的值留给bin、mail这样的系统账号。

＃useradd Oracle -g oinstall -G dba
新创建一个oracle用户，这初始属于oinstall组，且同时让他也属于dba组。

＃useradd tomcat  -d /var/servlet/service -s /sbin/nologin
无法使用shell，且其用户目录至/var/servlet/service


* commands
find . -type f -name \*.h
** awk , sed , grep 利器
  gerp 查找, sed 编辑, awk 根据内容分析并处理.
  $file * |awk '{print $1 $2}'|awk '{FS=":"} {print $1" " $1"."$2}' > args.txt
*** awk(关键字:分析&处理) 一行一行的分析处理
awk '条件类型1{动作1}条件类型2{动作2}' filename,
awk 也可以读取来自前一个指令的 standard input
Actions 是由许多awk指令构成. 而awk的指令与 C 语言中的指令十分类似.

相对于sed常常用于一整行处理, awk则比较倾向于一行当中分成数个"字段"(区域)来处理,
默认的分隔符是空格键或tab键。

例如:
last -n 5 | awk '{print $1 "\t" $3}' 这里大括号内$1"\t"$3 之间不加空格也可以,
不过最好还是加上个空格, 另外注意"\t"是有双引号的, 因为本身这些内容都在单引号内。

$0 代表整行 $1代表第一个区域, 依此类推

awk的处理流程是:
1. 读第一行, 将第一行资料填入变量 $0, $1... 等变量中
2. 依据条件限制, 执行动作
3. 接下来执行下一行

所以, awk一次处理是一行, 而一次中处理的最小单位是一个区域。
另外还有3个变量, NF: 每一行处理的字段数, NR 目前处理到第几行 FS 目前的分隔符。
逻辑判断 > < >= <= == !== , 赋值直接使用=

cat /etc/passwd | awk '{FS=":"} $3<10 {print $1 "\t" $3}'
首先定义分隔符为:, 然后判断, 注意看, 判断没有写在{}中, 然后执行动作,
FS=":"这是一个动作, 赋值动作, 不是一个判断, 所以写在{}中。

BEGIN END, 给程序员一个初始化和收尾的工作, BEGIN之后列出的操作在{}内
将在awk开始扫描输入之前执行, 而END{}内的操作, 将在扫描完输入文件后执行。
awk '/test/ {print NR}' abc
将带有test的行的行号打印出来, 注意//之间可以使用正则表达式
awk {}内, 可以使用 if else ,for(i=0;i<10;i++), i=1 while(i<NF)
可见, awk的很多用法都等同于C语言, 比如"\t" 分隔符, print的格式,
 if, while, for 等等

awk程序中允许呼叫Shell指令. 并提供管道解决awk与系统间数据传递的问题. 所以awk很容易使用系统资源. 读者可利用这个特点来编写某些适用的系统工具.
awk 提供与 UNIX 用法近似的 pipe, 其记号亦为 "|". 其用法及含意如下 :
http://blog.csdn.net/wisgood/article/details/8894702
awk程序中可接受下列两种语法:
[a. 语法] awk output 指令 | "Shell 接受的命令"

( 如 : print $1,$2 | "sort -k 1" )

[b. 语法] "Shell 接受的命令" | awk input 指令

( 如 : "ls " | getline)

注 : awk input 指令只有 getline 一个.
awk output 指令有 print, printf() 二个.

*** sed(关键字: 编辑) 以行为单位的文本编辑工具
	sed可以直接修改档案, 不过一般不推荐这么做, 可以分析 standard input
基本工作方式: sed [-nef] '[动作]' [输入文本]
-n : 安静模式, 一般sed用法中, 来自stdin的数据一般会被列出到屏幕上, 如果使用-n参数后, 只有经过sed处理的那一行被列出来.
-e : 多重编辑, 比如你同时又想删除某行, 又想改变其他行, 那么可以用 sed -e '1,5d' -e 's/abc/xxx/g' filename
-f : 首先将 sed的动作写在一个档案内, 然后通过 sed -f scriptfile 就可以直接执行 scriptfile 内的sed动作 (没有实验成功, 不推荐使用)
-i : 直接编辑, 这回就是真的改变文件中的内容了, 别的都只是改变显示. (不推荐使用)
动作:
a 新增, a 后面可以接字符串, 而这个字符串会在新的一行出现. (下一行)
c 取代, c 后面的字符串, 这些字符串可以取代 n1,n2之间的行
d 删除, 后面不接任何东西
i 插入, 后面的字符串, 会在上一行出现
p 打印, 将选择的资料列出, 通常和 sed -n 一起运作 sed -n '3p' 只打印第3行
s 取代, 类似vi中的取代, 1,20s/old/new/g

[line-address]q 退出, 匹配到某行退出, 提高效率

[line-address]r 匹配到的行读取某文件 例如: sed '1r qqq' abc , 注意, 写入的文本是写在了第1行的后边, 也就是第2行

[line-address]w file, 匹配到的行写入某文件  例如: sed -n '/m/w qqq' abc , 从abc中读取带m的行写到qqq文件中, 注意, 这个写入带有覆盖性.


举例:
sed '1d' abc 删除 abc 档案里的第一行, 注意, 这时会显示除了第一行之外的所有行, 因为第一行已经被删除了(实际文件并没有被删除,而只是显示的时候被删除了)
sed -n '1d' abc 什么内容也不显示, 因为经过sed处理的行, 是个删除操作, 所以不现实.
sed '2,$d' abc 删除abc中从第二行到最后一行所有的内容, 注意, $符号正则表达式中表示行末尾, 但是这里并没有说那行末尾, 就会指最后一行末尾, ^开头, 如果没有指定哪行开头, 那么就是第一行开头
sed '$d' abc 只删除了最后一行, 因为并没有指定是那行末尾, 就认为是最后一行末尾
sed '/test/d' abc 文件中所有带 test 的行, 全部删除
sed '/test/a RRRRRRR' abc 将 RRRRRRR 追加到所有的带 test 行的下一行 也有可能通过行 sed '1,5c RRRRRRR' abc
sed '/test/c RRRRRRR' abc 将 RRRRRRR 替换所有带 test 的行, 当然, 这里也可以是通过行来进行替换, 比如 sed '1,5c RRRRRRR' abc

*** grep(关键字: 截取) 文本搜集工具, 结合正则表达式非常强大
主要参数 []
-c : 只输出匹配的行
-I : 不区分大小写
-h : 查询多文件时不显示文件名
-l : 查询多文件时, 只输出包含匹配字符的文件名
-n : 显示匹配的行号及行
-v : 显示不包含匹配文本的所有行(我经常用除去grep本身)
基本工作方式: grep 要匹配的内容 文件名, 例如:
grep 'test' d* 显示所有以d开头的文件中包含test的行
grep 'test' aa bb cc 显示在 aa bb cc 文件中包含test的行
grep '[a-z]\{5}\' aa 显示所有包含字符串至少有5个连续小写字母的串

** xargs , exec
-exec: {}表示命令的参数,即所找到的文件,以 ; 表示 command 命令的结束。\是转义符，
因为分号在命令中还有它用途，所以就用一个\来限定表示这是一个分号而不是表示其它意思。

-ok： 和 -exec 的作用相同，格式也一样，只不过以一种更为安全的模式来执行该参数
所给出的shell给出的这个命令之前，都会给出提示，让用户来确定是否执行。

例子
$find . -name 'core' -type f -exec rm {} \;
find -exec 命令会对每个匹配的文件执行一个单独的rm操作（execute a separate rm for each one）
使用这种方式，如果有100个文件匹配了，那么就需要启100个进程，一个进程处理一个rm命令。

# xargs 要结合管道来完成
格式：find [option] express |xargs command

前提是后面的命令必须支持多参数。
有些命令，比如unzip，就不支持输入多个jar包，所以必须用-exec。
xargs，顾名思义，是对参数进行处理的命令。
它的任务就是将输入行转换成下一个命令的参数列表。
因此上面的find -exec命令可以改写成：

$find . -name 'core' -type f -print | xargs rm

# 比较
$find test/ -type f |xargs echo
test/myfile.name test/files/role_file test/files/install_file

$find test/ -type f -exec echo {} \;
test/myfile.name
test/files/role_file
test/files/install_file

很明显，exec是对每个找到的文件执行一次命令，除非这单个的文件名超过了几k，否则不
会出现命令行超长出报错的问题。

而xargs是把所有找到的文件名一股脑的转给命令。当文件很多时，这些文件名组合成的命
令行参数很容易超长，导致命令出错。

另外， find | xargs 这种组合在处理有空格字符的文件名时也会出错，因为这时执行的命令
已经不知道哪些是分割符、哪些是文件名中的空格！ 而用exec则不会有这个问题。

# 相比之下，也不难看出各自的缺点
1、exec 每处理一个文件或者目录，它都需要启动一次命令，效率不好; 
2、exec 格式麻烦，必须用 {} 做文件的代位符，必须用 \; 作为命令的结束符，书写不便。
3、xargs 不能操作文件名有空格的文件；

综上，如果要使用的命令支持一次处理多个文件，并且也知道这些文件里没有带空格的文件，
那么使用 xargs比较方便; 否则，就要用 exec了。
# xargs -i 等同于 -exec
cat args.txt|xargs -i echo {}

* 如何处理包含空格和特殊字符的文件名
包含特殊字符的文件名的例子，并不常见：

#232.txt
#bkf.txt
#bjsd3469.txt
#121nkfd.txt
-2232.txt
-fbjdew.txt
-gi32kj.txt
--321.txt
--bk34.txt
...
一个显而易见的问题是 - 在这个星球上有谁会创建和处理包含井号(#)，分号(;)，破折号(-)或其他特殊字符的文件/文件夹啊！

我和你想的一样，这种文件名确实不常见，不过在你必须得处理这种文件名的时候你的 shell 也不应该出错或罢工。而且技术上来说，Linux 下的一切比如文件夹、驱动器或其他所有的都被当作文件处理。

处理名字包含破折号(-)的文件
创建以破折号(-)开头的文件，比如 -abx.txt。

$ touch -abc.txt
测试输出
touch: invalid option -- 'b'
Try 'touch --help' for more information.
出现上面错误的原因是，shell 把破折号(-)之后的内容认作参数了，而很明显没有这样的参数，所以报错。

要解决这个问题，我们得告诉 Bash shell（是的，这里以及本文后面的大多数例子都是基于 BASH 环境）不要将特殊字符（这里是破折号）后的字符解释为参数。

有两种方法解决这个错误：

$ touch -- -abc.txt     [方法 #1]
$ touch ./-abc.txt      [方法 #2]
你可以通过运行命令 ls 或 ls -l 列出详细信息来检查通过上面两种方式创建的文件。

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 11:05 -abc.txt
要编辑上述文件可以这样：

$ nano -- -abc.txt 
或者 
$ nano ./-abc.txt 
注意：你可以将 nano 替换为任何其他你喜欢的编辑器比如说 vim：

$ vim -- -abc.txt 
或者 
$ vim ./-abc.txt 
如果只是简单地移动文件可以这样：

$ mv -- -abc.txt -a.txt
或者
$ mv -- -a.txt -abc.txt
删除这种文件，可以这样：

$ rm -- -abc.txt
或者
$ rm ./-abc.txt 
如果一个目录下有大量这种名字包含破折号的文件，要一次全部删除的话，可以这样：

$ rm ./-*
重要：

上面讨论的规则可以同样应用于名字中包含任意数量以及任意位置的连接符号的文件。就是说，-a-b-c.txt，ab-c.txt，abc-.txt，等等。

上面讨论的规则可以同样应用于名字中包含任意数量以及任意位置连接符号的文件夹，除了一种情况，在删除一个文件夹的时候你得这样使用rm -rf：

$ rm -rf -- -abc 或者 $ rm -rf ./-abc

处理名字包含井号(#)的文件
符号#在 BASH 里有非常特别的含义。#之后的一切都会被认为是评论，因此会被 BASH 忽略。

通过例子来加深理解：

创建一个名字是 #abc.txt 的文件：

$ touch #abc.txt
测试输出
touch: missing file operand
Try 'touch --help' for more information.
出现上面错误的原因是，BASH 将 #abc.txt 解释为评论而忽略了。所以命令 touch没有收到任何文件作为参数，所以导致这个错误。

要解决这个问题，你可能需要告诉 BASH 不要将 # 解释为评论。

$ touch ./#abc.txt
或者
$ touch '#abc.txt'
检查刚创建的文件：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 12:14 #abc.txt
现在创建名字中除了开头的其他地方包含 # 的文件。

$ touch ./a#bc.txt
$ touch ./abc#.txt    
或者
$ touch 'a#bc.txt'
$ touch 'abc#.txt'
运行 ‘ls -l‘ 来检查：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 12:16 a#bc.txt
-rw-r--r-- 1 avi avi 0 Jun  8 12:16 abc#.txt
如果同时创建两个文件（比如 a 和 #bc）会怎么样：

$ touch a.txt #bc.txt
检查刚创建的文件：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 12:18 a.txt
很明显上面的例子中只创建了文件 a 而文件 #bc 被忽略了。对于上面的情况我们可以这样做，

$ touch a.txt ./#bc.txt
或者
$ touch a.txt '#bc.txt'
检查一下：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 12:20 a.txt
-rw-r--r-- 1 avi avi 0 Jun  8 12:20 #bc.txt
可以这样移动文件：

$ mv ./#bc.txt ./#cd.txt
或者
$ mv '#bc.txt' '#cd.txt'
这样拷贝：

$ cp ./#cd.txt ./#de.txt
或者
$ cp '#cd.txt' '#de.txt'
可以使用你喜欢的编辑器来编辑文件：

$ vi ./#cd.txt
或者
$ vi '#cd.txt'
 
$ nano ./#cd.txt
或者
$ nano '#cd.txt'
这样删除：

$ rm ./#bc.txt 
或者
$ rm '#bc.txt'
要删除所有以井号（#）开头的文件，可以这样：

# rm ./#*
处理名字包含分号(;)的文件
如果你还不知道的话，分号在 BASH 里起到命令分隔的作用，其他 shell 可能也是一样的。分号作为分隔符可以让你一次执行几个命令。你碰到过名字包含分号的文件吗？如果没有的话，这里有例子。

创建一个名字包含分号的文件。

$ touch ;abc.txt
测试输出
touch: missing file operand
Try 'touch --help' for more information.
bash: abc.txt: command not found
出现上面错误的原因是，在运行上面命令的时候 BASH 会把 touch 解释为一个命令但是在分号前没有任何文件参数，所以报告错误。然后报告的另一个错误找不到命令 abc.txt，只是因为在分号后 BASH 会期望另一个新的命令，而 abc.txt 并不是一个命令。

要解决这个问题，我们得告诉 BASH 不要将分号解释为命令分隔符，例如：

$ touch ./';abc.txt'
或者
$ touch ';abc.txt'
注意：我们将文件名用单引号 '' 包含起来。这样可以告诉 BASH 分号 ; 是文件名的一部分而不是命令分隔符。

对名字包含分号的文件和文件夹的其他操作（就是，拷贝、移动、删除）可以直接将名字用单引号包含起来就好了。

处理名字包含其他特殊字符的文件/文件夹
文件名包含加号 (+)
不需要任何特殊处理，按平时的方式做就好了，比如下面测试的文件名。

$ touch +12.txt 
文件名包含美元符 ($)
你需要将文件名用单引号括起来，像处理分号那样的方式。然后就很简单了。

$ touch '$12.txt'
文件名包含百分号 (%)
不需要任何特殊处理，当作一个普通文件就可以了。

$ touch %12.txt
文件名包含星号 (*)
需要用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改。）

$ touch *12.txt
注意：当你需要删除星号开头的文件时，千万不要用类似下面的命令。

$ rm *
或者
$ rm -rf *
而是用这样的命令，(LCTT 译注：此处原文有误，已修改）

$ rm ./'*.txt'
文件名包含叹号 (!)
只要将文件名用单引号括起来，其他的就一样了。

$ touch '!12.txt'
文件名包含小老鼠 (@)
没有什么特别的，可以将名字包含小老鼠的文件当作普通文件。

$ touch '@12.txt'
文件名包含 ^
不需要特殊处理。可以将名字包含 ^ 的文件当作普通文件。

$ touch ^12.txt
文件名包含 (&)
将文件名用单引号括起来，然后就可以操作了。

$ touch '&12.txt'
文件名包含括号 ()
如果文件名包含括号，你需要将文件名用单引号括起来。

$ touch '(12.txt)'
文件名包含花括号 {}
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch '{12.txt}'
文件名包含尖括号 <>
名字包含尖括号的文件需要用单引号括起来。

$ touch '<12.txt>'
文件名包含方括号 [ ]
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch '[12.txt]'
文件名包含下划线 (_)
这个非常普遍，不需要特殊对待。当作普通文件随意处理。

$ touch _12.txt
文件名包含等号 (=)
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch '=12.txt'
处理反斜杠 ()
反斜杠会告诉 shell 忽略后面字符的特殊含义。你必须将文件名用单引号括起来，就像处理分号那样。其他的就没什么了。

$ touch '\12.txt'
包含斜杠的特殊情形
除非你的文件系统有问题，否则你不能创建名字包含斜杠的文件。没办法转义斜杠。

所以如果你能创建类似 ‘/12.txt’ 或者 ‘b/c.txt’ 这样的文件，那要么你的文件系统有问题，或者支持 Unicode，这样你可以创建包含斜杠的文件。只是这样并不是真的斜杠，而是一个看起来像斜杠的 Unicode 字符。

文件名包含问号 (?)
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch '?12.txt'
文件名包含点 (.)
在 Linux 里以点 (.) 开头的文件非常特别，被称为点文件。它们通常是隐藏的配置文件或系统文件。你需要使用 ls 命令的 ‘-a‘ 或 ‘-A‘ 开关来查看这种文件。

创建，编辑，重命名和删除这种文件很直接。

$ touch .12.txt
注意：在 Linux 里你可能碰到名字包含许多点 (.) 的文件。不像其他操作系统，文件名里的点并不意味着分隔名字和扩展后缀。你可以创建名字包含多个点的文件：

$ touch 1.2.3.4.5.6.7.8.9.10.txt
检查一下：

$ ls -l
 
total 0
-rw-r--r-- 1 avi avi 0 Jun  8 14:32 1.2.3.4.5.6.7.8.9.10.txt
文件名包含逗号 (,)
你可以在文件名中使用逗号，可以有任意多个而不用特殊对待。就像平时普通名字文件那样处理。

$ touch ,12.txt
或者
$ touch ,12,.txt
文件名包含冒号 (:)
用单引号括起来或使用反斜杠转义。（LCTT 译注：此处原文有误，已修改）

$ touch ':12.txt'
或者
$ touch ':12:.txt'
文件名包含引号（单引号和双引号）
要在文件名里使用引号，我们需要使用交替规则。例如，如果你需要在文件名里使用单引号，那就用双引号把文件名括起来。而如果你需要在文件名里使用双引号，那就用单引号把文件名括起来。（LCTT 译注：或者如果单引号和双引号混杂的情况，你也可以用反斜杠转义。）

$ touch "15'.txt"
 
以及
 
$ touch '15".txt'
文件名包含波浪号 (~)
Linux 下一些像 emacs 这样的文本编辑器在编辑文件的时候会创建备份文件。这个备份文件的名字是在原文件名后面附加一个波浪号。你可以在文件名任意位置使用波浪号，例如：

$ touch ~1a.txt
或者
$touch 2b~.txt
文件名包含空格
创建名字的字符/单词之间包含空格的文件，比如 “hi my name is avishek.txt”。

最好不要在文件名里使用空格，如果你必须要分隔可读的名字，可以使用下划线或横杠。不过，你还是需要创建这样的文件的话，你可以用反斜杠来转义下一个字符。要创建上面名字的文件可以这样做。

$ touch hi\ my\ name\ is\ avishek.txt
 
hi my name is avishek.txt
我已经尝试覆盖你可能碰到的所有情况。上面大多数测试都在 BASH Shell 里完成，可能在其他 shell 下会有差异。

如果你觉得我遗漏了什么（这很正常也符合人性），请把你的建议发表到下面的评论里。保持联系，多评论。不要走开！求点赞求分享求扩散！

* git & hub: GitHub 积累与分享
  # local git server. 方便使用版本管理功能：比较、备份、还原、共享。
   https://git-scm.com/book/zh/v2
   https://git-scm.com/downloads
   https://man.openbsd.org/sshd
   git clone /home/git/project.git
   git clone ssh://user@host/home/git/project.git
   # git config --global core.editor "vim"
** git server and users
** .gitignore
	首先要强调一点，这个文件的完整文件名就是“.gitignore”，注意最前面有个“.”。
	这样没有扩展名的文件在Windows下不太好创建，这里给出win7的创建方法：
	创建一个文件，文件名为：“.gitignore.”，注意前后都有一个点。保存之后系统会自动重命名为“.gitignore”。
	一般来说每个Git项目中都需要一个“.gitignore”文件，这个文件的作用就是告诉Git哪些文件不需要添加到版本管理中。

下面我们看看常用的规则：

/mtk/ 过滤整个文件夹
*.zip 过滤所有.zip文件
/mtk/do.c 过滤某个具体文件

很简单吧，被过滤掉的文件就不会出现在你的GitHub库中了，当然本地库中还有，只是push的时候不会上传。

需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：

!*.zip
!/mtk/one.txt

唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。

为什么要有两种规则呢？想象一个场景：我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理。
那么我们就需要使用：

/mtk/
!/mtk/one.txt

假设我们只有过滤规则没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！

最后需要强调的一点是，如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。

简单来说，出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。
git rm --cached FILENAME
所以大家一定要养成在项目开始就创建.gitignore文件的习惯，否则一旦push，处理起来会非常麻烦。

1、配置语法：
　　以斜杠“/”开头表示目录；
　　以星号“*”通配多个字符；
　　以问号“?”通配单个字符
　　以方括号“[]”包含单个字符的匹配列表；
　　以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；

　　此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；

2、示例：
　　（1）规则：fd1/*
　　　　  说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；
　　（2）规则：/fd1/*
　　　　  说明：忽略根目录下的 /fd1/ 目录的全部内容；
　　（3）规则：
/*
!.gitignore
!/fw/bin/
!/fw/sf/
说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；

# 语法规范
空行或是以#开头的行即注释行将被忽略。
可以在前面添加正斜杠/来避免递归,下面的例子中可以很明白的看出来与下一条的区别。
可以在后面添加正斜杠/来忽略文件夹，例如build/即忽略build文件夹。
可以使用!来否定忽略，即比如在前面用了*.apk，然后使用!a.apk，则这个a.apk不会被忽略。
*用来匹配零个或多个字符，如*.[oa]忽略所有以".o"或".a"结尾，*~忽略所有以~结尾的文件（这种文件通常被许多编辑器标记为临时文件）
[]用来匹配括号内的任一字符，如[abc]，也可以在括号内加连接符，如[0-9]匹配0至9的数
?用来匹配单个字符。
来个栗子：
# 忽略 .a 文件
*.a
# 但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件
!lib.a
# 仅在当前目录下忽略 TODO 文件， 但不包括子目录下的 subdir/TODO
/TODO
# 忽略 build/ 文件夹下的所有文件
build/
# 忽略 doc/notes.txt, 不包括 doc/server/arch.txt
doc/*.txt
# 忽略所有的 .pdf 文件 在 doc/ directory 下的
doc/**/*.pdf


* vi
** leader 快捷键
长久以来我都是使用 , 做为Leader，直到我意识到我可以使用键盘上更加好用的捷按键：空格键（<Space>）。
let mapleader = "\<Space>"
这个完全颠覆了我的 Vim 操作效率，我现在可以使用双手任何一个大拇指进行操作，同时其它手指可以保持在键盘的主键区。

** 寄存器 reg
一：官方帮助手册
:help registers
:help :registers

二： 寄存器分类

1.无名（unnamed）寄存器：""，缓存最后一次操作内容；

2.数字（numbered）寄存器："0 ～ "9，缓存最近操作内容，复制与删除有别, "0寄存器缓存最近一次复制的内容，"1-"9缓存最近9次删除内容

3.行内删除（small delete）寄存器："-，缓存行内删除内容；

4.具名（named）寄存器："a ～ "z或"A - "0Z，指定时可用；

5.只读（read-only）寄存器：":, "., "%, "#，分别缓存最近命令、最近插入文本、当前文件名、当前交替文件名；

6.表达式（expression）寄存器："=，只读，用于执行表达式命令；

7.选择及拖拽（selection and drop）寄存器："*, "+, "~，存取GUI选择文本，可用于与外部应用交互，使用前提为系统剪切板（clipboard）可用；

8.黑洞（black hole）寄存器："_，不缓存操作内容（干净删除）；

9.模式寄存器（last search pattern）："/，缓存最近的搜索模式。


三：查看寄存器内容
:reg         查看所有寄存器内容
:reg 寄存器名  查看单个寄存器内容   比如 :reg _        :reg *            :reg 1           :reg 9          :reg a 等等


数字寄存器，也是最常用的 从0-9。 如果不指定寄存器的名字，那么删除的内容，vim默认是存到 1 ，复制内容是存到 0 号寄存器。 如果继续删除，那么原来 1 的内容就转到 2，类推，当删除超过9的时候， 原先的 8号数字寄存器就转到9， 原先9的数字寄存器内容就会丢失。

实验1：
先在vim里面输入1-0 10个数字，每个数字一行，接着从0 9 8 7 6 5 4 3 2 依次dd删除，然后:reg查看寄存器，接着yy复制数字1的这行，可以看见"0 寄存器 的值是1

“1 ～ ”9 寄存器依次是 2~0

使用p来粘贴，如果最近一次操作是复制，那么p就会添加 “0 寄存器的内容，如果最近一次操作是删除那么就添加 "1 寄存器的内容 ，如果要粘贴其它数字寄存器的内容，

使用 "?p 来粘贴，比如要粘贴 “2 寄存器里面的，则在vim命令模式下 输入 "2p 就可以取出“2寄存器里面的内容了

其他的寄存器都是通过 "?p 来访问使用的。


具名寄存器（字母寄存器），也就是名称是单个英文字母， "a "b "c ,....,"z ， 使用时，在复制或者删除命令 y 或者 d 时，在前面加上字母寄存器的字母名称就可以了, 或者是直接在删除或者复制命令后 加上字母寄存器的字母 比如  :y n 就是复制当前行到 “n 字母寄存器  :5,10y m 复制5到10行内容到 “m 字母寄存器 

:pu! n  将字母寄存器 “n的内容粘贴到当前行之前 也可以使用 "mP 效果一样

:p n  粘贴字母寄存器 ”n 的内容到当前行的下一行 也可以使用 "np 效果一样

(命令模式下  :y :d :pu 分别是复制 删除 和粘贴

一般模式下 "寄存器名y  “寄存器名d "寄存器名p  代表着复制 删除 和 粘贴 )


实验2：
"ayy  就是复制当前行到 "a 字母寄存器中

 "b3yy 复制当前行和下面2行 到 “b 字母寄存器

“ap 粘贴 “a 字母寄存器的内容

“cd2l 向右删除2个字符 并且把内容存到 字母寄存器 “c 中            “cp 粘贴 ”c 字母寄存器里面的内容

”d3dd 删除当前行和下面2行 并且把内容存到 字母寄存器 “d 中  

“fdf.     删除当前位置到句号  并且把内容存到 字母寄存器 “f 中

“gd'c 删除当前位置到标记c位置 并且把内容存到 字母寄存器 “g 中

同一个字母的大写和小写表示的是同一个寄存器，但是行为会不同，字母寄存器的名称大写时，当使用大写的寄存器进行复制或者删除文本时，原先的字母寄存器中的内容会被保留，刚删除或复制的内容则附加到原来字母寄存器内容的后面。 字母寄存器只有在指定时才被使用。


无名寄存器 ""  保存最近一次复制或删除的文本。就是p命令默认使用的寄存器。

短删除寄存器 "- （The small delete register）。事实上刚删除的文本并不一定被送到数字寄存器，如果删除的文本不含换行符（不足一整句）则文本被送至这个寄存器。如x、d2h这两条命令删除的文本都会被送到这个寄存器。注意下在这条命令虽然删除了一整行的文本但因不含换行符所以也被送到这个寄存器`0d$‘。

只读寄存器  ": ". "% "# 它们分别用来保存最近一次在命令行窗口使用的命令、最近一次插入的文本、当前编辑的文件名、当前的替代文件名。

表达式寄存器 "=

选择与拖放的寄存器"* "+ "~ 在Windows中这几个寄存器就是剪贴板。在Linux中它们也是剪贴板——但这几个寄存器是有所区别的。

黑洞寄存器 "_ 删除操作会影响现有数字寄存器的内容。前一个数字寄存器的值传给后一个数字寄存器，"9的内容被丢弃，新删除的文本则放入"1。这至少有两个直接的影响，一是"9的内容被丢弃；二是寄存器中文本的位置都发生了变化。而复制操作会改变"0的值。如果你不希望删除或复制的操作影响数字寄存器的话就使用这个寄存器。使用这个寄存器进行删除或复制的内容都会被丢弃——这还可以提高一点速度节省一点空间。

搜索式样寄存器 "/ 保存上一次搜索所使用的式样。注意这也包括了s命令中所使用的搜索式样。



寄存器有26个字母寄存器可以使用；可以使用大写字母将文本附加到已有内容后。如果在你关闭文件之前还没想到这将这些内容贴在哪里也没关系，

用`:wviminfo my_viminfo‘命令。下一次编辑时输入`:rviminfo! my_viminfo‘或者在命令行用这个命令运行`gvim -i my_viminfo myfile‘，:reg看寄存器的内容都在的。


四 。寄存器是个变量——特殊的变量，只要在前面加上一个@号就可以用变量的方式访问寄存器。

所以，变量的操作也同样适用于寄存器。

" 给寄存器赋值
let @e="开始\<CR>"
let @E="结束"
echo @e
开始
结束
" 将寄存器作为表达式的一部分
let my_var=@a . @c
" 和
echo @e+4
" 清空寄存器。
" 注意：不能用unlet清除寄存器。
:let @e=""


在编辑窗口与命令窗口间交换内容

编辑窗口的文本可以放进寄存器。搜索式样和上一条Ex命令被放进了只读寄存器"/和":。
已知寄存器的内容可以在贴到编辑窗口。可以在命令窗口作为变量使用。那有没有办法在命令窗口插入寄存器的内容呢？有没有办法在搜索式样中插入寄存器的内容呢？

比如，假设在寄存器e中保存着一个文件名：“这是一个保存在寄存器中的很长的文件名.txt”。而我想使用:w命令保存一个当前编辑文件的副本——使用寄存器e中的那个文件名。如果使用`:w @e‘的话，文件名将是“@e”而不是“这是一个保存在寄存器中的很长的文件名.txt”。这时该怎么办呢？考虑到寄存器也是变量，我们可以使用寄存器的传统办法。

" 方法一。使用:execute命令
" 写入以"e为名的寄存器中
:exe "w " . @e
那搜索呢？如果我们要在搜索式样中使用寄存器的内容呢？对于s命令的搜索式样上面的:exe大法仍然适用，但如果只是普通的搜索操作（在一般模式中按/）呢？我们要用到组合键Ctrl-R，用Vim的写法就是<C-R>。

" 方法二。使用Ctrl-R转义。
" 搜索寄存器e的内容。<Ctrl-R>表示用户在这里按了组合键Ctrl-R——不要直接输入<Ctrl-R>这8个字符。
/<Ctrl-R>e/
使用<C-R>的方式可适用于各种输入的环境中：在插入模式输入时、在命令窗口输入时、在搜索时。在插入模式时要输入寄存器内容并不需要退回到一般模式再使用p指令，可以直接按`<Ctrl-R>e‘当然e可以改成相应的寄存器名。在命令窗口与搜索时也是一样：按Ctrl-R输入寄存器名。

提示：除了一些不接受变量作为参数，不能使用寄存器名称的情况外，还有一些情况也要求插入寄存器的内容。有时我们插入寄存器的内容而不使用寄存器变量是因为我们可能还需要手工对寄存器的内容进行一些编辑。

无名寄存器总是保存着最近一次复制或删除的内容。不带寄存器名地使用p就可以添加该寄存器的内容到当前位置了。但是既然“无名”该怎么在命令窗口使用这个存器呢？又怎么插入无名寄存器的内容呢？答案是使用@"，插入也是一样按Ctrl-R再按输入"就可以了。

现在总结一下：":保存了上一条Ex命令。"/保存了上一条搜索式样。字母寄存器及数字寄存器中可以保存编辑的文本。并且我们也可以在不同的环境中插入寄存器的内容。通过寄存器我们可以方便地在命令窗口编辑窗口以及搜索中交换内容。相对而言一般的变量就没这么方便，你只能在命令行中使用变量也只能是命令行中给变量赋值。

 在buffer之间及程序之间交换内容

寄存器是全局的变量。在Vim中打开的所有文件2，共享这些寄存器。你可以在不同的文件之间交换内容。

通过寄存器"*和"+，Vim可以与其他程序交换信息。在Windows中这两个寄存器是一样的。在Linux中这两个寄存器则有所不同。
:help gui-selections
:help x11-selection

寄存器可以做为宏

跟一般的变量相比寄存器还有一个最大的特点就是寄存器本身可以做为宏使用。如果你有用过一般模式命令q的话就会发现q录制的击键序列就是存在寄存器中的，并且可以直接使用寄存器执行命令。现在做做实验，新建一文档随便输入几行文字。输入：
qeggddq
上面这条命令录制了一个宏并保存到寄存器e中。这个宏的作用是回到第一行并删除该行。现在看一下寄存器的内容：
:reg e
就是你刚才的键盘命令ggdd。要运行刚录制的键盘操作在一般模式输入@e就可以运行了，输入3@e会将前三行删除。
当然你不一定要用q来录制宏——因为寄存器也是变量。
:let @e="/删除本行/^Mdd:w^M"
@e
上面的^M表示的是回车键。可不是输入^再输入M，而是输入Ctrl-V（Windows是Ctrl-Q）再按回车键这时就会出现^M表示这是一个回车键。常见的还有^[表示的是<ESC>键。输入的方法也是一样按Ctrl-V再按Esc键。这样输入控制字符的方式是传统的Vi方法。在Vim中也支持用按键名表示这些控制字符。比如<CR>表示回车键3所以上面的命令也可表示为：
:let @e="/删除本行/\<CR>dd:w\<CR>"
这里一定要用双引号，我们在“脚本”一篇中已经讲到了，在单引号中的字串会被当成普通字串。后面这种表示控制字符的方式与'cpoptions'的设置有关，虽然在默认情况下都是可行的但是建议使用第一种方式。不过为了更好的可读性在教程中我们还是可能使用后面这种方式表示控制字符。
正因为寄存器可以直接执行所以":可以用来执行上一条在命令窗口使用的命令：
:@:
记得最后要按回车执行。当然现在由于命令行的历史功能这种用法没有什么实用价值。

在重定向命令中使用
重定向命令（:redir）是一个较常用的技巧。所有的字母寄存器、@*、无名寄存器（@"）都可以在重定向命令中使用。还是用个例子说明好了：
假设你的小说家朋友寄了一本小说的初稿给你，但显然他没有整理文本的习惯——好消息是他这次竟然没用Word写。在你往下看之前你决定先将文档做适当的整理。使用Vim作这种事当然是小菜一碟，只用了10分钟你就将他的小说整理成一份格式整齐的文档了。

** 标记 mark
利用:marks命令，可以列出所有标记。这其中也包括一些系统内置的特殊标记（Special marks）：

. ——最近编辑的位置
0-9 ——最近使用的文件
∧ ——最近插入的位置
' ——上一次跳转前的位置
" ——上一次退出文件时的位置
[ ——上一次修改的开始处
] ——上一次修改的结尾处

# 命令小结
m ——创建标记
' ——移动到标记的文本行首
` ——移动到标记的光标位置
:marks ——列示所有标记
:delmarks ——删除指定标记
:delmarks! ——删除所有标记

* emacs, evil(vi)
** keys
clear 多个空格  M-SPC just-one-space| M-\ delete-horizontal-space
*** evil keys same to vim
*** leader keys
(evil-leader/set-leader "<SPC>")
(setq evil-leader/non-normal-prefix "M-")

(evil-leader/set-key "k" 'kill-buffer)
(evil-leader/set-key "f" 'find-file)
(evil-leader/set-key "w" 'save-buffer)
(evil-leader/set-key "o" 'other-frame)
(evil-leader/set-key "h" 'previous-buffer)
(evil-leader/set-key "l" 'next-buffer)
# (evil-leader/set-key "n" 'evil-normal-state)
(evil-leader/set-key "<SPC>" 'evil-normal-state)
;; "b" 'switch-to-buffer
(evil-leader/set-key
  "hl" 'highlight-bookmarks-the-buffer
  "hh" 'highlight-bookmarks-clean
  "l" 'bookmark-bmenu-list
  "m" 'bookmark-set
  "b" 'bookmark-jump)

** 不断进化，且具有强大的进化能力
  https://github.com/lujun9972/emacs-document
  # 在emacs中运行Linux shell命令：M-!
1. 学无止境 elisp
2. 熟能生巧 keys
3. 温故而知新，随Emacs主程序版本一起，更新插件，重构*.el和配置
** 寄存器 register C-xr
   Emacs 寄存器是通用的存储机制，它可以存储很多内容中的一项，
   包括文本、矩形区块、缓冲区中的位置，或者某些其他值或设置。
   每个寄存器都有一个标签，您可以使用单个字符来引用寄存器。
   可以重定义寄存器，但是它一次只能包含一项内容。
   一旦您退出 Emacs，将清空所有的寄存器。

   # 所有的 Emacs 寄存器命令都是以 C-xr 开头的。

键盘输入	功能	描述
C-x r space X	point-to-register	将光标保存到寄存器 X。
C-x r s X	copy-to-register	将区域保存到寄存器 X。
C-x r r X	copy-rectangle-to-register	将选定的矩形区块保存到寄存器 X。
未定义	view-register	查看一个给定的寄存器的内容。
C-x r j X	jump-to-register	将光标移动到寄存器 X 中给定的位置。
C-x r i X	insert-register	在光标处插入寄存器 X 的内容。
** 书签 bookmark C-xr
   Emacs 提供了保存缓冲区中位置的另一种工具
   这些 Emacs 书签的工作方式与寄存器相同，但是它们的标签可以超过一个字符长
   而且它们比寄存器更为持久：如果保存了书签，那么您可以在两个不同的会话之间使用它们
   它们将一直保留下来，直到您删除它们

   要在当前缓冲区中，为您正在访问的文件的当前光标设置一个书签
   可以运行 bookmark-set 功能，它与 C-x r m 进行了绑定。

   bookmarks-bmenu-list 功能可以列出一个由已设置的所有书签组成的菜单
   通过键入 C-x r l 运行该功能

   可以通过直接跳转至某个书签，而无需从书签列表中选择它
   要跳转至某个特定的书签，可以使用 bookmark-jump 功能，C-x r b。
   如果尚未在缓冲区中打开这个带书签的文件，那么这一命令将打开它。

   删除一个书签，键入 C-x bookmark-delete 并按 Enter

   bookmark-save 将所有的书签保存到书签文件 ~/.emac.bmk 中。

   # visual bookmark, highlight bookmark line
 http://www.gnu.org/software/emacs/manual/html_node/elisp/Finding-Overlays.html
 http://raebear.net/comp/emacscolors.html

(progn  (goto-line 462)
(let
     ((overlay-highlight (make-overlay
						  (+ 10 (line-beginning-position))
						  (- (line-end-position) 10))))
  (overlay-put overlay-highlight 'face '(:background "green"))
  (overlay-put overlay-highlight 'line-highlight-overlay-marker t))) (remove-overlays (line-beginning-position) (+ 1 (line-end-position)))

(remove-overlays (point-min) (point-max))
(goto-char 11184)

1. 读取 bookmarks 文件
   bookmark-default-file
   (bookmark-all-names)
   (nth 3 (bookmark-all-names))
   (bookmark-get-bookmark (nth 3 (bookmark-all-names)))
   (bookmark-get-bookmark (car (bookmark-all-names)))
   (bookmark-get-bookmark-record (car (bookmark-all-names)))
   (bookmark-get-position (nth 3 (bookmark-all-names)))
   (bookmark-get-handler (car (bookmark-all-names)))
2. 查看当前文件是否有书签
   (buffer-file-name)
   (bookmark-get-filename (car (bookmark-all-names)))
 (expand-file-name "~/project/sspdf/src/ci.hpp")
   (file-truename )
3. 调用高亮书签的函数
(highlight-bookmarks-the-buffer)
(mapcar
 (lambda (bmk)
   (if (string= (buffer-file-name) (bookmark-get-filename bmk))
	   (let ((pos (bookmark-get-position (nth 3 (bookmark-all-names))))
	   hlpos
			 )
		 (setq hlpos (make-overlay pos (+ 3 pos)))
		 (prin1 hlpos)
		 (overlay-put hlpos 'face '(:background "green"))
		 (overlay-put hlpos 'line-highlight-overlay-marker t))
	 (message bmk)
	 ))
	 (bookmark-all-names))
   
(defun highlight-bookmarks-the-buffer ()
    (mapcar ...)
)

4. 如果一打开就高亮，则需要buffer hook

** 编码
1.查看当前buffer的编码：M-x describe-coding-system
2.列出所有编码：C-x <RET> r <TAB>
3.以指定编码重读当前buffer：C-x <RET> r utf-8，（revert-buffer-with-coding-system）
4.改变当前buffer的编码：C-x <RET> f utf-8，（set-buffer-file-coding-system）
5.设定下一步操作的编码格式：C-x <RET> c，（universal-coding-system-argument）

** Evil 将 Emacs变为Vim
   https://github.com/emacs-evil/evil
   Evil-mode出现了. 它完美的模拟了Vim.
   Evil-mode的开发者公开宣称Evil-mode应该与Vim一模一样,
   任何不一样的地方都视为BUG.
   然后有一些相熟的资深Vim党也开始用这个Evil-mode,于是我知道了,这个mode确实很棒.
   https://github.com/lujun9972/emacs-document

   Emacs默认文本对象能力不强, 有了evil的拓展 C-o di" 轻轻松松搞定~
   http://www.kuqin.com/shuoit/20150727/347223.html
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (package-initialize)
Then:
  M-x package-refresh-contents
  M-x package-install RET evil

 (require 'evil)
 (evil-mode 1)

 Thanks Evil, 把 Emacs 打造成了理想的 “Vim 化的 Emacs Editor” 
 然后还在 .bashrc 里添加了alias vi='emacs -nw'，
 不要纠结是 Vim, Emacs 还是 Evil，他只是我的编辑器。

 默认配置完全模拟 Vim，除了用 Ctr-z 来切换模式。
 调整成在 Insert 模式下恢复 Emacs 键绑定，用 Esc 退到 Normal 模式。
 
 <N>C-e/C-y, <E>M-n/M-p
 <E>C-y/M-y yank, yank-pop

 Enable evil
 (setq evil-toggle-key "")
 ; remove default evil-toggle-key C-z, manually setup later
 (setq evil-want-C-i-jump nil)
; don't bind [tab] to evil-jump-forward
 (require 'evil)
 (evil-mode 1)
 ;; remove all keybindings from insert-state keymap, use emacs-state when editing
 (setcdr evil-insert-state-map nil)
 ;; ESC to switch back normal-state
 (define-key evil-insert-state-map [escape] 'evil-normal-state)
 ;; TAB to indent in normal-state
 (define-key evil-normal-state-map (kbd "TAB") 'indent-for-tab-command)
 ;; Use j/k to move one visual line insted of gj/gk
 (define-key evil-normal-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
 (define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
 (define-key evil-motion-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
 (define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
 
** leader 可绑定 Emacs 命令
# try
(require 'evil-leader)
(setq evil-leader/in-all-states t)
(evil-mode nil)
(global-evil-leader-mode 1)
(evil-mode 1)

(evil-leader/set-key "f" 'find-file)
;; "b" 'switch-to-buffer
;; "k" 'kill-buffer)
(evil-leader/set-key
  "l" 'bookmark-bmenu-list
  "m" 'bookmark-set
  "b" 'bookmark-jump)

** 复制粘贴
1、在网上广为流传的一种让emacs和系统剪切板共享的方法是在.emacs文件中加入

(setq x-select-enable-clipboard t)
这种方法仅对图形化emacs有效，如果用 emacs -nw 命令打开emacs的话，在命令行中是无效的，因为在命令行下没有权限访问 X 的剪切板（http://unix.stackexchange.com/questions/72605/emacs-copy-and-paste）。

2、正因为第1点，所以网上同时流传着另一种方法：

;;start 设置剪切板共享 

(defun copy-from-osx () 

(shell-command-to-string "pbpaste")) 

(defun paste-to-osx (text &optional push) 

(let ((process-connection-type nil)) 

(let ((proc (start-process"pbcopy" "*Messages*" "pbcopy"))) 

(process-send-string proc text) 

(process-send-eof proc)))) 

(setq interprogram-cut-function 'paste-to-osx) 

(setq interprogram-paste-function 'copy-from-osx) 

;;end 设置剪切板共享 

这种方法确实可用，但是里面的pbpaste和pbcopy命令根本不是Linux下的，而是mac下的。所以在linux下应该找到等效的命令替换它们。

3、linux下的剪切板操作命令

找到了两种：xclip和xsel

这两个命令linux不自带，需要安装。两种命令的具体使用方法不做介绍，总之nicek在网上找到了一个适用于linux下的配置（http://hugoheden.wordpress.com/2009/03/08/copypaste-with-emacs-in-terminal/）：

;; http://hugoheden.wordpress.com/2009/03/08/copypaste-with-emacs-in-terminal/
;; I prefer using the "clipboard" selection (the one the
;; typically is used by c-c/c-v) before the primary selection
;; (that uses mouse-select/middle-button-click)
(setq x-select-enable-clipboard t)

;; If emacs is run in a terminal, the clipboard- functions have no
;; effect. Instead, we use of xsel, see
;; http://www.vergenet.net/~conrad/software/xsel/ -- "a command-line
;; program for getting and setting the contents of the X selection"
(unless window-system
 (when (getenv "DISPLAY")
  ;; Callback for when user cuts
  (defun xsel-cut-function (text &optional push)
    ;; Insert text to temp-buffer, and "send" content to xsel stdin
    (with-temp-buffer
      (insert text)
      ;; I prefer using the "clipboard" selection (the one the
      ;; typically is used by c-c/c-v) before the primary selection
      ;; (that uses mouse-select/middle-button-click)
      (call-process-region (point-min) (point-max) "xsel" nil 0 nil "--clipboard" "--input")))
  ;; Call back for when user pastes
  (defun xsel-paste-function()
    ;; Find out what is current selection by xsel. If it is different
    ;; from the top of the kill-ring (car kill-ring), then return
    ;; it. Else, nil is returned, so whatever is in the top of the
    ;; kill-ring will be used.
    (let ((xsel-output (shell-command-to-string "xsel --clipboard --output")))
      (unless (string= (car kill-ring) xsel-output)
	xsel-output )))
  ;; Attach callbacks to hooks
  (setq interprogram-cut-function 'xsel-cut-function)
  (setq interprogram-paste-function 'xsel-paste-function)
  ;; Idea from
  ;; http://shreevatsa.wordpress.com/2006/10/22/emacs-copypaste-and-x/
  ;; http://www.mail-archive.com/help-gnu-emacs@gnu.org/msg03577.html
 ))
** elisp
You can evaluate an expression and see its result in any of several ways, including:
+ Put your cursor after the last close-paren and type C-j (control + j)
+ Put your cursor inside the expression and type M-C-x (alt + control + x)
+ Put your cursor after the last close-paren and type C-x C-e

*** Lexical Stuff
Comments:
Single-line only. They start with a semicolon:
(blah blah blah)   ;  I am a comment
(message "Hello World!") ; elisp first

Characters:
?x is the syntax for an ASCII character: ? followed by the character.
e.g.: ?a is ascii 97 ('a'), ? (that is, question-mark space) is ascii 32 (' ').
Some need to be escaped, such as ?\(, ?\) and ?\\
Emacs 22+ has unicode support. Out of scope for this primer.
`C-x 8 RET'

Numbers:
Integers are 29 bits of precision (not the usual 32). -32, 0, 157, etc.
Binary:         start with #b, e.g. #b10010110
Octal:          #o[0-7]+, e.g. #o377
Hexadecimal:    start with #x, e.g. #xabcd, #xDEADBEE
Floating-point: the usual. -10.005, 0.0, 3.14159265 (64 bits of precision.)
Scientific:     the usual. 6.02e23, 5e-10
The variables most-positive-fixnum and most-negative-fixnum are the largest
and smallest integers representable in Emacs Lisp without bignum support.

Strings:
Double-quoted only.
"He's said: \"Emacs Rules\" one time too many."

You can embed newlines in strings, like so:
"Oh Argentina!
Your little tin of pink meat
Soars o'er the Pampas"

Booleans:
The symbol t (just a letter 't' by itself) is true.
The symbol nil is false (and also means null).
In Emacs Lisp, nil is the only false value;
everything else evalutes to true in a boolean context,
including empty strings, zero, the symbol 'false, and empty vectors.
An empty list, '(), is the same thing as nil.

Arrays:
Elisp has fixed-sized arrays called "vectors".
[-2 0 2 4 6 8 10]
["No" "Sir" "I" "am" "a" "real" "horse"]
["hi" 22 120 89.6 2748 [3 "a"]]
Note that you do not (and cannot) use commas to separate the elements; use whitespace.
Vectors can have mixed-type elements, and can be nested.
You usually use the function make-vector to create them,
since literal vectors are singletons, which can be surprising.
# 操作
(setq xyz ["str" 3.14 [() ?d] 'some])
(aref xyz 2)
(aset xyz 0 "zsl")
(aref xyz 0)

Lists:
Lisp makes heavy use of linked lists, so there's lexical syntax for them.
Anything in parentheses is a list, but unless you quote it, it will be evaluated as a function call.
There are various ways to quote things in Lisp:
(quote (1 2 3)) ; produces the list (1 2 3) with no list-element evaluation
'(1 2 3)  ; apostrophe is shorthand for (quote (...))
          ; note that it goes _outside_ the left-paren
(list 1 (+ 1 1) 3) ; also produces (1 2 3), since it evaluates the elements first
`(1 ,(+ 1 1) 3)  ; another (1 2 3) via a template system called "backquote"
There's a lot more that could be said about lists, but other people have already said it.

Pairs:
You can set the head and tail (also known as car and cdr) fields of a lisp link-list node struct
(also known as a cons cell) directly, using it as a 2-element untyped struct.
The syntax is (head-value . tail-value), and you have to quote it (see above).

A common lookup-table data-structure for very small data sets is an associative list (known as an alist).
It's just a list of dotted pairs, like so:
'( (apple . "red")
   (banana . "yellow")
   (orange . "orange") )
Emacs Lisp has built-in hashtables, bit-vectors, and miscellaneous other data structures,
but there's no syntax for them; you create them with function calls.

*** Operators
  Some operations that are typically operators in other languages are function calls in elisp.
Equality:
Numeric equality: (= 2 (+ 1 1)) Single-equal. Yields t or nil. Works for floats too.
Not-numerically-equal: (/= 2 3) I know, it looks like assign-divide-equal. But it's not.

Value equality: (eq 'foo 2) Like Java ==. Works for ints, symbols, interned strings, and object references.
 Use eql for floating-point numbers (or just =).

Deep (structural) equality: use equal, as in:
(equal '(1 2 (3 4)) (list 1 2 (list 3 (* 2 2))))  ; true

The equal function is like Java's Object.equals(). Works for lists, vectors, strings, and just about anything else.

String
Strings don't have any operators, but there are lots of string functions. Some common ones:
(concat "foo" "bar" "baz")  ; yields "foobarbaz"
(string= "foo" "baz")  ; yields nil (false).  Can also use equal.
(substring "foobar" 0 3) ; yields "foo"
(upcase "foobar")  ; yields "FOOBAR"

Do M-x apropos RET \bstring\b RET to see a list of functions related to strings.
(apropos "string")

Arithmetic

Easiest to show as a table...
| C/Java/JS Operator | Emacs Lisp                         | Example         |                       Result |
| +                  | +                                  | (+ 1 2 3 4 5)   |                           15 |
| -                  | -                                  | (- 6 2 3)       |                            1 |
| *                  | *                                  | (* 2 -1 4.2)    |                         -8.4 |
| /                  | /                                  | (/ 10 3)        | 3 (use floats for float div) |
| %                  | %                                  | (% 10 3)        |                            1 |
| <<                 | lsh                                | (lsh 1 5)       |                           32 |
| >>                 | ash (negative amount)              | (ash -32 -4)    |                           -2 |
| >>>                | lsh (negative amount)              | (lsh 32 -4)     |                            2 |
| ++                 | incf (requires 'cl library)        | (incf x 6)      |                          x+6 |
| --                 | decf (ditto)                       | (decf x 5)      |                          x-5 |
| ? : (ternary)      | (if test-expr then-expr else-expr) | (if t 3 4)      |                            3 |
| &&                 | and                                | (and t t t nil) |                          nil |

|| or  (or nil nil nil t)  t
! (logical-not)	not	(not 3)	nil
~ (bit-not)	lognot	(lognot #b1001)	-10
^ (bit-xor)	logxor	(logxor 5 3)	6
& (bit-and)	logand	(logand 1 3)	1
| (bit-or)	logior	(logior 1 3)	3
<	<	(< 5 3)	nil
>	>	(> 5 3)	t
<=	<=	(<= 3 3)	t
>=	>=	(>= 5 3)	t
. (field access)	see setf below	n/a	n/a
[] (array access)	aref/aset	(aref [2 4 6] 1)	4

*** Statements
This section has some recipes for simple Java-like statements.
It's not comprehensive – just some recipes to get you going.

if/else
Case 1: no else clause: (if test-expr expr)
Example:
(if (>= 3 2)
  (message "hello there"))

Case 2: else clause: (if test-expr then-expr else-expr)
(if (today-is-friday)         ; test-expr
    (message "yay, friday")   ; then-expr
  (message "boo, other day")) ; else-expr

If you need multiple expressions (statements) in the then-expr,
you wrap them with a call to progn, which is like curly-braces in C or Java:
(if (zerop 0)
    (progn
      (do-something)
      (do-something-else)
      (etc-etc-etc)))

You don't need the progn around the else-expr
-– everything after the then-expr is considered to be part of the else-expr. Hence:
(if (today-is-friday)
    (message "yay, friday")
  (message "not friday!")
  (non-friday-stuff)
  (more-non-friday-stuff))

Case 3: else-if clause: Just nest 'em. Or use cond (see below).
(if 'sunday
    (message "sunday!")      ; then-expr
  (if 'saturday              ; else-if
      (message "saturday!")  ; next then-expr
    (message ("weekday!")))) ; final else

Case 4: no else-if, multiple body expressions – use when:
If you don't have an else-clause, then you can use the when macro, which provides an implicit progn:
(when (> 5 1)
  (blah)
  (blah-blah)
  (blah blah blah))

You can also use unless, which is like when but inverts the sense of the test:
(unless (weekend-p)
  (message "another day at work")
  (get-back-to-work))

switch
Elisp has two versions of the classic switch statement: cond and case.

Elisp does not have a table-lookup optimization for switch,
so cond and case are just syntax for nested if-then-else clauses.
However, if you have more than one level of nesting, it looks a lot nicer than if expressions.
The syntax is:
(cond
  (test-1
    do-stuff-1)
  (test-2
    do-stuff-2)
  ...
  (t
    do-default-stuff))

The do-stuff parts can be any number of statements, and don't need to be wrapped with a progn block.

Unlike classic switch, cond can handle any test expression (it just checks them in order), not just numbers.
The downside is that it doesn't have any special-casing for numbers, so you have to compare them to something.
Here's one that does string compares:
(cond
 ((equal value "foo")  ; case #1 – notice it's a function call to `equal' so it's in parens
  (message "got foo")  ; action 1
  (+ 2 2))             ; return value for case 1
 ((equal value "bar")  ; case #2 – also a function call (to `+')
  nil)                 ; return value for case 2
 (t                    ; default case – not a function call, just literal true
  'hello))             ; return symbol 'hello

The final t default clause is optional. The first matching clause is executed,
and the result of the entire cond expression is the result of the last expression in the matching clause.

The 'cl (Common Lisp) package bundled with Emacs provides case, 
which works if you're comparing numbers or symbols, 
so in a sense it works more like standard switch. Example:
(case 12
  (5 "five")
  (1 "one")
  (12 "twelve")
  (otherwise
   "I only know five, one and twelve."))  ; result:  "twelve"

With case you can use either t or otherwise for the default case, but it must come last.
It's cleaner to use case when you can get away with it, but cond is more general.

while
Elisp has a relatively normal while function: (while test body-forms)
Example, which you can evaluate in your *scratch* buffer:
(setq x 10
      total 0)
(while (plusp x)  ; while x is positive
  (message (int-to-string x))
  (incf total x)  ; add x to total
  (decf x))       ; subtract 1 from x

First we set two global variables, x=10 and total=0, then run the loop.
Then we can evaluate the expression total to see that its value is 55 (the sum of the numbers 1 to 10).

*** local variables
You declare function local variables with the let form.
The basic syntax is (let var-decl var-decl)
(let ((name1 value1)
      (name2 value2)
      name3
      name4
      (name5 value5)
      name6
      ...))
Each var-decl is either a single name, or (name initial-value).
You can mix initialized and uninitialized values in any order.
Uninitialized variables get the initial value nil.

You can have multiple let clauses in a function.
Code written for performance often collects all declarations into a single let at the top,
since it's a bit faster that way. Typically you should write your code for clarity first.

*** 学习
	http://www.woola.net/detail/2016-08-18-elisp.html

*** 补充，数组
   _____________________________________________
   |                                             |
   |          Sequence                           |
   |  ______   ________________________________  |
   | |      | |                                | |
   | | List | |             Array              | |
   | |      | |    ________       ________     | |
   | |______| |   |        |     |        |    | |
   |          |   | Vector |     | String |    | |
   |          |   |________|     |________|    | |
   |          |  ____________   _____________  | |
   |          | |            | |             | | |
   |          | | Char-table | | Bool-vector | | |
   |          | |____________| |_____________| | |
   |          |________________________________| |
   |_____________________________________________|

** Ivy 只完成一件事，以及。。。
   https://github.com/lujun9972/emacs-document/blob/master/advertisement/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E4%BB%8EVim%E8%BF%81%E7%A7%BB%E5%88%B0Emacs+Evil.org
   Ivy 为实现最小化，简单化，可定制化，可发现化而努力.
   这四个形容词告诉我们很多Helm 和Ivy 这两个工具间不同的设计理念。

   在写这篇文章的时候，Ivy 只有大概3400行代码，为Ivy 所打造的生态系统：即Swipter 和 Counsel 也只有7500 行代码
   git clone https://github.com/abo-abo/swiper.git
   cd swiper
   ## Only ivy ?
   cat ivy.el | wc -l
   # => 3442
   
   ## count lines of code into the whole swiper ecosystem
   cat *.el | wc -l
   # => 7526

** 扩展推荐
   https://www.zhihu.com/question/21943533/answer/22145491
   company 取代auto-complete,更新很频繁
   yasnippet 代码模板,关键是可内嵌lisp代码执行，太强悍了!接下来唯一的限制就是你的想象力了
   js2-mode javascript开发神器(sublime之流和它根本不是一个数量级的)
   evil-mode 把emacs变成vim，基本vim有的它都有了比如text object，最酷的是可以写lisp自定义text object
   evil-leader 很简单的一个plugin,但是用好的话,让你效率成倍提升.
   evil-matchit 在成对的tag跳来跳去, vim的matchit移植版但更强大(我写的)
   evil-nerd-commenter 按行注释代码, nerd-comment的移植版(我写的)
   helmweb-mode 通吃html所有相关
   windows-numbering.el 子窗口跳转的终极方案,用过所有的编辑器,没有比这个好的了.
   smex 不用再记快捷键了
   # ====补充===
   我先入为主地认为提问者指的是需要安装的第三方扩展,Emacs自带的扩展我补充一下：
   org-mode gtd工具,神级别的软件,和git,vim,emacs是一个档次的
   winner-mode undo窗口layout很有用
   gnus 让我又爱又恨,Emacs其他插件太牛逼, 和yasnippet结合用,和company-mode,和evil等等,所以gnus要伴我终生了.
   ido 类似于helm，和helm各有千秋我都用,五五开,不过helm有个让我爱死的设置,可以选择何时使用ido,helm或者两者都不用.
   # 开源真的不错呃,世界级高手都是惺惺相惜的.不像那些专有软件,菜鸟开发,即使是同一个公司,还要互相往死里掐.
   imenu 显示当前文件函数列表,可以直接跳转到那去,完全可配置,支持所有语言flymake 实时语法检查,通吃所有语言
   flyspell 拼写检查,爱死了,是我见过的所有拼写检查最强大,如果你知道如何配置.
   # ====再补充===
   也许最好的插件就是Lisp语言本身,强大,简单易学,其语法看似诡异,于是自动过滤了菜鸟.
   我的另一个诀窍就是一旦发觉一个好的插件,立即调查原作者,
   务必把他所有开发的使用的工具调查清楚.
   比如mooz维护的的js2-mode让我爱不释手,于是我调查他开发的其他工具,
   keysnail - firefox模拟成Emacs,我用过的同类软件中最好的,细节无可挑剔
   percol - python开发的命令行工具,天才的作品,我现在的工作流主要就靠它,
   没有它我效率要大大降低.

** compile el -> elc
byte-compile-file
byte-recompile-file

* Makefile

* xwindow 和 字符界面切换
  # 未配置的字符界面，不支持中文。
** 一般有 ALT+CTRL+F1----F6为字符终端（字符界面），ALT+CTRL+F7为图形界面。
   不同的发行版本可能有一些差别，但切换方法都是一样的。

  1、按ALT+CTRL+F1切换到字符界面（Linux实体机）
  如果是VMware虚拟机安装的linux系统，则切换到字符界面的时候需要以下操作
  
  按下ALT+CTRL+SPACE(空格)，ALT+CTRL不松开，再按F1。这样就可以切换到字符界面了。
  
  2、按ALT+CTRL+F7切换到图形界面（Linux实体机）
  
  如果是VMware虚拟机安装的Linux系统，则切换到图形界面的时候需要以下操作
  
  按下ALT+CTRL+SPACE(空格)，ALT+CTRL不松开，再按F7。这样就可以切换到图形界面了。
    
  如果想 Ubuntu 在每次启动到 command prompt ，可以输入以下指令:
  
  $echo “false” | sudo tee /etc/X11/default-display-manager
  
  当下次开机时，就会以命令行模式启动（text模式，字符界面登录），如果想变回图形界面启动（X windows启动），可以輸入:
  
  $echo “/usr/sbin/gdm” | sudo tee /etc/X11/default-display-manager
  
  如果在Ubuntn以命令行模式启动，在字符终端想回到图形界面的话只需以下命令:
  $startx

** xterm/uxterm
   XTerm是一个X Window System上的终端模拟器，用来提供多个独立的SHELL输入输出。
   虚拟终端Xterm是X11标准指定的虚拟终端,历史非常悠久。
   Xterm的缺点:Xterm不支持中文。不过我们可以用Xterm的变种UXterm。
   # xterm 的所有相关设置都在一个名叫 .Xdefaults 的配置文件中
** 新终端： Tilda， F1一键呼出的终端。
** 添加完字体后, 可以用 xlsfonts 命令检查一下是否添加成功


* 安装谷歌浏览器，只需要三行代码： 
打开终端，输入 
cd /tmp 
对于谷歌Chrome32位版本，使用如下链接：
wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb

对于64位版本可以使用如下链接下载：
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 
下载完后，运行如下命令安装。

sudo dpkg -i google-chrome*; sudo apt-get -f install 


* 使用 so 中的类，具体的做法是：
1. 准备一份头文件，加入一个纯虚父类ABase，并声明createA,releaseA；
2. 在生成A.so的实现源码中，写业务类AHello，继承ABase，并导出上面提到的两个函数createA,releaseA；
3. 需要使用A.so的代码，使用dlopen打开so文件,dlsym导入createA,releaseA, 调用createA返回ABase指针类型的实际是AHello类型的实例，便可以使用这个AHello类实例了；
4. 调用raleaseA释放AHello实例。

注意：
1. 基类是纯虚类，不然编译器怎么在编译的时候知道AHello的实现在哪里？
2. 函数导入出需要加上extern “C”防止导出名字被修改。

class shape{ public:
   virtual void draw()=0;
};
class circle : public shape { public:
   void draw();
}

// the class factories
extern "C" shape* create() {
    return new circle;
}
extern "C" void destroy(shape* p) {
    delete p;
}


* libtool link warning xxx was moved.
  打开 xxx.la 查看 libdir 的路径是否正确？
