* [pdf asn1 RFCn openssl CryptoApi Qt xpdf/poppler linux.so jdk]
* TODO 开源世界 http://docs.huihoo.com/open-source/guide/
* OID http://www.oid-info.com  http://www.china-oid.org.cn/
* GB 标准下载网站 http://www.bzmfxz.com/
* TODO OpenSSL study
  证书的例子：
  被证明人：老王
  内容：通过了英语六级
  盖章：教育部门的公章或钢印
  # 阮一峰 http://www.ruanyifeng.com/blog/
** DONE openssl windows上编译安装
前提： 安装 perl
从开始菜单启动VS的命令行
Debug # perl Configure --debug VC-WIN32 no-asm no-async --prefix=d:/OpenSSLdbg
Release # perl Configure VC-WIN32 no-asm no-async --prefix=D:/OpenSSL
编辑 Configure 文件，注释掉  "crypto-mdebug"       => "default", 想要启用内存检查
nmake
nmake test
nmake install 管理员身份运行
*** 问题处理
打开 vs2010 命令行的时候，出现设置环境变量错误：“此时不应有 。。。”
“Setting environment for using Microsoft Visual Studio 此时不应有“系列问题的罪魁祸首。
关于环境变量的设置。 具体在【我的电脑】->【属性】->【高级系统设置】->【环境变量】，系统变量里面的PATH变量的值。
大概是因为系统的path变量中不允许写双引号”“, 检查错误提示，看哪个路径带了双引号，删除重写添加一次就 OK。
当把其中的双引号去掉之后，先退出 Visual Studio，再打开 Visual Studio，通过菜单栏 再次打开Visual Studio命令提示符的时候，就显示正常了。


C:\Users\zsl\AppData\Local\bin\NASM
*** openssl Release
D:\opensource\openssl-1.1.0e>perl Configure VC-WIN32 no-asm no-async no-threads
** ASN.1 https://www.obj-sys.com/asn1tutorial/node1.html
   # 很好 https://wenku.baidu.com/view/5f34fb631ed9ad51f01df20d.html
   UTCTime values take the form of either "YYMMDDhhmm[ss]Z"
   openssl中ASN.1源码解读 http://blog.csdn.net/u010129119/article/details/53940865
   http://rocksaying.tw/archives/17760845.html

   应用实例 http://wiki.jikexueyuan.com/project/objc/security/17-3.html

/* Extract an ASN1 object from an ASN1_STRING */

void *ASN1_item_unpack(const ASN1_STRING *oct, const ASN1_ITEM *it)
{
    const unsigned char *p;
    void *ret;

    p = oct->data;
    if ((ret = ASN1_item_d2i(NULL, &p, oct->length, it)) == NULL)
        ASN1err(ASN1_F_ASN1_ITEM_UNPACK, ASN1_R_DECODE_ERROR);
    return ret;
}

 pbe2 = ASN1_item_unpack(aparam, ASN1_ITEM_rptr(PBE2PARAM));

struct asn1_object_st {
    const char *sn, *ln;
    int nid;
    int length;
    const unsigned char *data;  /* data remains const after init */
    int flags;                  /* Should we free this one */
};

struct asn1_string_st {
    int length;
    int type;
    unsigned char *data;
    /*
     * The value of the following field depends on the type being held.  It
     * is mostly being used for BIT_STRING so if the input data has a
     * non-zero 'unused bits' value, it will be handled correctly
     */
    long flags;
};

** pkcs7
   基于openssl pkcs7的封装
   https://www.virtualbox.org/svn/vbox/trunk/src/VBox/Devices/EFI/Firmware/CryptoPkg/Library/BaseCryptLib/Pk/CryptPkcs7Sign.c
   # ditto https://ja.osdn.net/projects/tinyvisor/scm/svn/blobs/head/trunk/uefi/CryptoPkg/Library/BaseCryptLib/Pk/CryptTs.c
   https://github.com/rhinstaller/shim
   The RFC3161 timestamp counterSignature is contained in unauthenticatedAttributes field of SignerInfo.
https://security.stackexchange.com/questions/80410/sign-pkcs7-and-verify-pkcs7-signature-with-openssl
http://stackoverflow.com/questions/19410688/pkcs7-signature-verification
http://blog.csdn.net/wzsy/article/list/10

PKCS7 的 attached 和 detached 方式的数字签名
搜遍了整个网络，都没有详细的说明。只在一个页面上有介绍，还模棱两可的，地址是：
http://docs.oracle.com/cd/E19398-01/820-1228/gfnmj/index.html

后来分析了代码才找到它们的不同。
1. attached 方式是将签名内容和原文放在一起，按 PKCS7 的格式打包。PKCS7的结构中有一段可以放明文，但明文必需进行ASN.1编码。在进行数字签名验证的同时，提取明文。这里的明文实际上是真正内容的摘要。

2. detached 方式打包的 PKCS7格式包中不包含明文信息。因此在验证的时候，还需要传递明文才能验证成功。同理，这里的明文实际上是真正内容的摘要。

从搜索结果来看，detached 方式的应用要频繁得多。
下面的地址有两者的代码示例：
http://blog.sina.com.cn/s/blog_4fcd1ea30100z8rz.html

** openssl, cryptography 密码术
*** alg 算法 数学
1. 非对称加密: RSA算法原理
   http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html
   http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html
*** concept 名词 概念
DEFINITION 4.1 (message authentication code syntax):
 A message authentication code or MAC is a tuple of probabilistic polynomial-time algorithms(Gen; Mac; Vrfy) fullling the following:
HMAC是构建MAC的一种方式, H代表使用在整个构建里面的Hash Function。
*** docs
	参考手册 https://wiki.openssl.org/index.php/Main_Page
	https://www.openssl.org/docs/
	https://www.ibm.com/developerworks/cn/linux/l-openssl.html
1. HTTPS连接最初的若干毫秒 http://kb.cnblogs.com/page/125257/
   关于作者
   Jeff 是一个软件开发工程师，他在http://www.moserware.com/上有一个自己的博客。
   注意：这篇文章最初发表在Moserware上面，也就是Jeff Moser的博客里。
   查看英文原文：The First Few Milliseconds of an HTTPS Connection。
2. HTTPS https://zhuanlan.zhihu.com/p/25030869
3. PKI http://pki-tutorial.readthedocs.io/en/latest/index.html
   http://pki-tutorial.readthedocs.io/en/latest/expert/
*** source
	https://wenku.baidu.com/view/ec4a94be998fcc22bcd10db9.html
	http://www.cnblogs.com/efzju/archive/2012/03/04/2378928.html
堆栈是一种先进后出的数据结构。是一种只允许在其一端进行插入或者删除的线性表。允许插入或删除操作的一端为栈顶，另一端称为栈底。对堆栈的插入和删除操作称为入栈和出栈。
1.1     概述
OpenSSL大量采用堆栈来存放数据。它实现了一个通用的堆栈，可以方便的存储任意数据。它实现了许多基本的堆栈操作，主要有：堆栈拷贝(sk_dup)、构建新堆栈（sk_new_null，sk_new）、插入数据（sk_insert）、删除数据（sk_delete）、查找数据（sk_find，sk_find_ex）、入栈（sk_push）、出栈（sk_pop）、获取堆栈元素个数（sk_num）、获取堆栈值（sk_value）、设置堆栈值（sk_set）和堆栈排序（sk_sort）。
1.2     堆栈相关结构描述
OpenSSL堆栈数据结构在crypto/stack/stack.h中定义

*** commands
1. ts 时间戳处理工具（客户端/服务器模式）。
   该命令是一个基本的时间戳权威认证机构（TSA）的客户端
   和服务器端应用程序（遵循RFC3161协议）。
   TSA是一个PKI调度工具中的一部分，它的角色是提供一个证明：
   证明某个数据在一段时间内存在。
***  OpenSSL 常用函数 —— 证书操作
http://blog.csdn.net/yyfzy/article/details/46798965
OpenSSL 实现了对 X.509 数字证书的所有操作。
包括签发数字证书、解析和验证证书等。 

涉及证书操作的主要函数有验证证书（验证证书链、有效期、CRL）、
解析证书（获得证书的版本、序列号、颁发者信息、主题信息、公钥、有效期等）。

主要函数
1、DER编码转换为内部结构函数
X509 *d2i_X509(X509 **cert, unsigned char **d, int len);
函数功能：把一个DER编码的证书数据转化成OpenSSL内部结构体。
参数：
cert：[OUT]X509 结构体。
D：[IN]DER 编码的证书数据指针地址。
Len[IN] 证书数据长度；

返回值：编码后的 X509 结构体数据

2、获得证书版本函数 X509_get_version
#define X509_get_version(x) ASN1_INTEGER_get((x)->cert_info->version)

参数：
x：[IN]X509*结构体数据结构。
返回值：证书版本，数据类型“LONG”

3、获得证书序列号函数
ASN1_INTEGER *X509_get_serialNumber(X509 *x);
返回值：证书序列号，数据类型“
ASN1_INTEGER
”
.

4、获得证书颁发者信息函数
X509_NAME *X509_get_issuer_name(X509 *a);
注
*
：
X509_NAME 结构体包括多个 X509_NAME_ENTRY
结
构
体
。
X509_NAME_ENTRY
保存了颁发者的信息，
这些信息包括对象和值
（
object 
和
value
）
。对象的类型包括国家、通用名、单位、组织、地区、邮件等。

5、
获得证书拥有者信息函数
X509_NAME *X509_get_subject_name(X509 *a);

6、获得证书有效期的起始日期函数
#define X509_get_notBefore(x) ((x)->cert_info->validity->notBefore)
返回值：
证书起始有效期，数据类型“
ASN1_TIME
”

7、
获得证书有效期的终止日期函数
#define X509_get_notAfter(x) ((x)->cert_info->validity->notAfter)

8、获得证书公钥函数
EVP_PKEY *X509_get_pubkey(X509 *x);

9、创建和释放证书存储区
X509_STORE *X509_STORE_new(void);

Void X509_STORE_free(X509_STORE *v);

函数功能：创建和释放一个
X509_STORE
结构体，主要用于验证证书。

10、向证书存储区添加证书
Int X509_STORE_add_cert(X509_STORE *ctx, X509 *x);
函数功能：添加信任的根证书到证书存储区。
返回值：
1
成功，否则为
0
 
11、向证书存储区添加证书吊销列表
Int X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x);
功能：添加
CRL
到证书存储区。
参数：
x：[IN] 证书吊销列表。
Ctx：[IN]证书存储区。
返回值：
1
成功，
否则为
0
。

12、创建证书存储区上下文环境函数
X509_STORE_CTX *X509_STORE_CTX_new(void);
返回值：操作成功返回证书存储区上下文环境指针，否则返回
NULL
。

13、释放证书存储区上下文环境
Void X509_STORE_CTX_free(X509_STORE_CTX *ctx);

14、初始化证书存储区上下文环境函数
Int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, 
X509 *x509, STACK_OF(X509) *chain);
函数功能：初始化证书存储区上下文环境，设置根证书、待验证的证书、
CA
证书链。

15、验证证书函数
Int X509_verify_cert(X509_STORE_CTX *ctx);
返回值：验证成功返回
1
，否则返回
0

** Object Identifier (OID)
  http://www.oid-info.com/get/1.2.840.113549.1.9.16.2.47
  object: id-smime-aa-timeStampToken (1.2.840.113549.1.9.16.2.14)
  {iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) aa(2) id-aa-timeStampToken(14)}
* curl 网络库
  # curl 编译通过(依赖 openssl, libssl2, zlib)
  https://curl.haxx.se/libcurl/c/curl_easy_setopt.html

* TODO 写pdf文件:疑问
  # 疑问： int nLastObjectNumber = pxref->getNumObjects();	 // 能否保证取得最大的对象编号？
编译 xpdf http://blog.csdn.net/u010808402/article/details/53741744
poppler 文档 https://freedesktop.org/wiki/Software/poppler/

* 申请时间戳
  # 可信时间戳是由国家授时中心进行授时与守时的监测，因每个国家只有一个国家授时中心，法律只对国家授时中心的时间认可。
int append_tsp_token(PKCS7_SIGNER_INFO *sinfo, unsigned char *token, int token_len)
{
// Appends the TSP TimestampToken to the existing PKCS7 signature as an unsigned attribute

	TS_RESP *tsp = d2i_TS_RESP(NULL, (const unsigned char**)&token, token_len);

	if (tsp != NULL)
	{
		PKCS7* token = tsp->token;

		int p7_len = i2d_PKCS7(token, NULL); 
		unsigned char *p7_der = (unsigned char *)OPENSSL_malloc(p7_len); 
		unsigned char *p = p7_der; 
		i2d_PKCS7(token, &p);

		if (!PKCS7_type_is_signed(token))
		{
			MWLOG(LEV_ERROR, MOD_APL, L"Error in timestamp token: not signed!\n");
			return 1;
		}

		//Add timestamp token to the PKCS7 signature object
		ASN1_STRING *value = ASN1_STRING_new();
		ASN1_STRING_set(value, p7_der, p7_len);

		int rc = PKCS7_add_attribute(sinfo, NID_id_smime_aa_timeStampToken,
				V_ASN1_SEQUENCE, value);

	}
	else
	{
		MWLOG(LEV_ERROR, MOD_APL, L"Error decoding timestamp token!\n");
		return 1;
	}

	return 0;

}
* TODO 是否可改进。 每天留点时间磨刀：从总体审视、学习或巩固深化、熟能生巧。
 openssl 有封装好的验证过程？ PKCS7_signatureVerify
 # emacs 开发环境以及git, GitBash:grep,vi 等linux工具
 VS 开发环境
 VS 开发环境磨刀 http://blog.csdn.net/hackbuteer1/article/details/6579608
 小番茄 http://www.wholetomato.com/
 
* 2017-06-26 08:50:35 本周目标：动态库，可以用openssl添加签名，添加盖章
* 2017-07-11 09:23:23 周二 添加签名
2. openssl.pkcs7sign
   1) get ByteRange and data, 用 PDFDoc 对象操作, 从原始长度往后查找
   2) openssl sign, with cert OK
   3) write to pdf, 现有代码就可以?
  # openssl 算个签名放进去试试
  ~/study/openssl
  # 图片调整正常
  # 印章库

* 2017-07-10 08:54:24 周一 本周目标：
1. openssl.sha1 OK
2. openssl.pkcs7sign
   1) get ByteRange and data
   2) openssl sign, with cert OK
   3) write to pdf
  # openssl 算个签名放进去试试
* 2017-07-07 10:17:47 周五 印章库 or 图片处理
  印章库，列表和图片
获取印章数据, QT显示和选择列表
获取和处理印章图片
计算图片坐标
** 工作周报 1 2 3 4 5
SSPDFSign_Server移植：xyz
** 转正个人总结
1. 工作很有料：[pdf asn1 RFCn openssl CryptoApi Qt xpdf/poppler linux.so jdk]
   已有的C++和系统软件开发技能，在全新领域中
2. 公司很和谐，同事的帮助
3. 具体工作内容小结：
   1. PDF 文件格式
   2. 安全技术和规范
   3. 安全编程：openssl, CryptoAPI
   4. 自有代码 PDFReader, PDFServer
   5. 添加 pkcs7 签名以及时间戳
   6. 移植（进行中）
* 2017-07-06 08:54:49 周四 显示签名域
  # 解决问题：page 对象没更新 Annots 属性； trailer 的 Prev 属性值错误。
* 2017-07-05 08:27:11 周三 Debug 签名域, 图片看不见
  # 1. 比较不同：Windows版产生的签名和Linux版
  # 2. 找出流程中注释掉的部分，需要迁移

  # 坐标计算和图片处理
  # 印章列表和选择印章， 配置文件
** 对比windows版本的PDF签名，四项不同：
1 /sig 对象多了三项： /FOL /M /SSD
2 XObject stream 长度和内容不同
3 少了 /page 对象的更新， 增加了 /Annots 属性
4 trailer 的 /Prev 值是 0， 不对。
# 对象序号没有问题？
** 梳理程序流程，找出其他需要修改的地方：
1 void SSPdfEditor::SetDoc(const char * strFileName)
  // _nLastXRefPos = _pDoc->getXRef()->getLastXRefPos();
2 SSPdfEditor::AddSign
  删掉了 #if SUPPORT_CACHE 部分。
  没有加 gLockMutex(&g_mutexsign);

//接口中坐标单位改为毫米，fCoorX, fCoorY   这是为啥？
fCoorX = fCoorX / 10;
fCoorY = fCoorY / 10; 

  // 3. 加载印章库与设置印章库, 判断是否已经加载过。
  // TODO
  // HINSTANCE hinst = GetModuleHandle(NULL);
  // pid_t pid = getpid();
  // myStampTool.SetInstance(hinst);
  // if(lOnline == 0)
  // 	myStampTool.SetOnline(FALSE);
  // else // lOnline非0即1，不会有其它值
  // 	myStampTool.SetOnline(TRUE);
  // myStampTool.SetSealNameAndPassword(strSealName, strPassword);

  //获取印章数据
  // int nSealDataLength = 0;
  // const BYTE *  strSealData = NULL;
  // strSealData = CStampManager::GetSealData(strSealName, nSealDataLength , strPassword);		
  // if(!strSealData || nSealDataLength == 0) {
  //     gUnlockMutex(&g_mutexsign);
  //     CToolsStampLib::ReleaseEStampHeap();
  //     return 6;		  
  //   } 

展开了这个函数在AddSign此处
 int nSignResult = SignPdfFile(myStampTool,strSealName,nPage, fCoorX,fCoorY, &diSealData,bBindTocert,strCertSubjectName,nAddedToCache, bCenterSign);
  分为三步：添加签名域，计算签名，填充签名值。 
  当前只做了第一步
* 2017-07-04 08:57:19 周二 成功添加签名域
page.GetKVString_AddAnnot 出错 Core dump
SSPage
Fast-forward
 sspdf/src/SSCatalog.cc          |  28 +++---
 sspdf/src/SSCatalog.h           |   4 +-
 sspdf/src/SSPage.cc             | 207 +++++++++++++++++++++++++++++++++-------
 sspdf/src/SSPage.h              |  24 +++--
 sspdf/src/SSPdfEditor.cpp       |  11 ++-
 sspdf/src/SSPdfObjects_Conc.cpp |  22 +++--
 sspdf/src/src.pro               |   2 +-
 sspdf/test/main.cc              |   1 +
 8 files changed, 229 insertions(+), 70 deletions(-)

* 2017-07-03 09:03:39 周一 步骤：签名域、签名值、写PDF文件。
  # bitmap 图片处理工具函数, 编译OK,待测
1. 添加签名域
2. 添加签名域功能： 用印章库，获取印章列表，印章数据，印章图片 
void CToolsStampLib::InitStampEnvironment(HINSTANCE hinst)
{	
	if(!g_CurModule)
	{
		#if MULTITHREADED
		  gInitMutex(&mutex);
		#endif

		g_CurModule = hinst;
		LoadEStampDll();
		LoadEccsdpDll();
	}
}
2. 印章图片的处理？ 是否需要

* 2017-06-30 08:45:15 周五 Trailer.cpp
  每天留点时间磨刀：从总体审视、学习或巩固深化。
  Trailer.cpp SSPdf_ObjectAddManager.cpp OK
  linux 图片处理探索，未果。
  test: addsign
* 2017-06-29 16:53:42 周四
  # 总结：使用了二进制重用的编程方法
  对象的扩展方法？
1. 迁移：添加签名域到PDF功能：
	new file:   sspdf/src/SSCatalog.cc
	new file:   sspdf/src/SSPage.cc
	modified:   sspdf/src/zztypedef.h
	new file:   sspdf/src/zzutils.hpp
 13 files changed, 850 insertions(+), 398 deletions(-)
2. test: undefined symbol: _ZTV7Trailer, 明天的任务
* 2017-06-28 08:46:00 周三 git&hub 
1. 迁移：添加签名域到PDF功能：SSPdfObject.cpp
   zztypedef.h
   # 添加成功，并测试
2. 安装局域网git，进行程序版本管理。
   ss:ss git:999 linuxg,888,windowsg:777
* 2017-06-27 08:37:01 周二  添加PDF文件解析功能，到框架
1. so测试程序 OK
2. 迁移：添加签名域到PDF功能，未完待续
	modified:   sspdf/src/SSPdfObjects_Conc.cpp

* 2017-06-26 08:49:20 周一 雏形开发继续
1. 接口定义文件 OK
   ci.hpp
   SSPdfEditor.cpp
2. 编译空壳so OK
3. 测试程序
  # 1. emacs-evil
  # 2. 先跑起来，一个原型，或叫做壳。包括：接口定义、测试用例。
  # 自顶向下，建立空架子；然后填充或替换，封装。
  # 测试程序同时建立
  # 数据结构保留， 数据类型统一定义：Windows, linux, sstypedef.h

* 2017-06-21 16:21:11 本周：CSSPdfDocManager 是对外的接口类，提供所有可用功能
  D:\codes3\product\SSPDFSign_Server\Code\SSPDFSignServer\SSPdfDocManager.h
  # 分析需要移植修改的内容， 移植方法： 替换，修改，重写
  # 一条一条线索理清
** void SetDoc(const char * strFileName)
   m_pDoc = new PDFDoc(gstrfilename, NULL, NULL);
   m_nLastObjectNumber = m_pDoc->getXRef()->getNumObjects();
   m_nLastXRefPos = m_pDoc->getXRef()->getLastXRefPos();
*** PDFDoc 跨平台
	D:\codes3\product\SSPDFSign_Server\Code\SSPDFSignServer\SSPdf_Doc.h
** int IsOK() 是否正常打开了一个PDF文件
** BOOL CanChange()
** // 插入签名 AddSign
	int nRes = GetOpPageNumber(nPageNum, nPage);
	Cache_SealData * pMgrSealData = Cache_SealData::getInstance();
	gLockMutex(&g_mutexsign);
	CStampManager myStampTool;
	HINSTANCE hinst = GetModuleHandle(NULL);
	# hinst 用于防止动态库重复加载
	myStampTool.SetInstance(hinst);
*** GetModuleHandle Windows系统函数
*** CStampManager
	void CToolsStampLib::SetInstance(HINSTANCE hinst)
	{
	InitStampEnvironment(hinst);
	}

void CToolsStampLib::InitStampEnvironment(HINSTANCE hinst)
{	
	if(!g_CurModule)
	{
		#if MULTITHREADED
		  gInitMutex(&mutex);
		#endif

		g_CurModule = hinst;
		# LoadEStampDll(); 加载动态库 EStamp.dll 和里面的接口，windows平台相关
		LoadEccsdpDll();
	}
}

//获取印章数据
strSealData = CStampManager::GetSealData(strSealName, nSealDataLength , strPassword);
# 从印章数据获取公钥，用新的 GMESEAL 是否可代替？
int nResGetCert = GetCertSubjectName_ForSign(diSealData, strCertSubjectName);
# 获取印章图片： ？？在哪里有接口
int nres = stampTool.GetSealBitmapSize(nbitmapwo, nbitmapho, nbitmapwp, nbitmaphp);
# 印章图片操作，位图，用到Windows的GDI
**** 印章图片的坐标计算
HDC screen = GetDC(NULL);
	double hPixelsPerInch = GetDeviceCaps(screen,LOGPIXELSX);
	double vPixelsPerInch = GetDeviceCaps(screen,LOGPIXELSY);

Catalog * pcatalog = m_pDoc->getCatalog();
Page * page = pcatalog->getPage(nPage);
PageAttrs * pageattris = page->attrs;
PDFRectangle * pcropbox = pageattris->getCropBox();

*** SignPdfFile # 签名
int nSignResult = SignPdfFile(myStampTool, strSealName, nPage, fCoorX, fCoorY, &diSealData,  bBindTocert, strCertSubjectName.c_str(), nAddedToCache, bCenterSign);
# pdf 文件长度，Windows
int nRes = GetFileLength_Win(strFileName, dwFileLength);
# 创建 UUID， Windows
nRes = GetUniqNameByGUID(strGUID);

# 用印章图片创建签名域， PDF增量更新操作
nRetVal = AddSign_Prev(nPage, dwFileLength, xStampPos1, yStampPos1, xStampPos2, yStampPos2, strSignName, pPicData, bBindCert, pSealData->value, pSealData->size);
# 计算签名并添加到文件
int nResSign = SignFile_CalcSignValue_InsertToFile(dwFileLength, stampTool, strSignName, pSealData,  bBindCert, strCertName);
# 计算 sha1
const char * bDigest = CalFileDigest(strInFile, nbyteranges[0], nbyteranges[1], nbyteranges[2], nbyteranges[3], 1);	
# if(!bBindCert)  用印章库签名？
strSignResult = myStampTool.CalcSignValue((const BYTE *)bDigest, nDigestLength, nSignResultLength);
# else 用Windows CryptoAPI和本地安装的证书签名
strSignResult = GetSignData_SignByCert((const BYTE *)bDigest_Bin, dbDigestLength_Bin, nSignResultLength, (char *)strCertName);

# 是否绑定证书的区别？ contents的内容不一样？
if(!bBindCert)
nSaveRes = SaveSignValueToFile(pSealData->value, pSealData->size, diSignResult.value, diSignResult.size, (char *)strInFile, lOrigFileLength, lFileLength, startpos, endpos);	
else
nSaveRes = SaveSignValueToFile_Direct(diSignResult.value, diSignResult.size, (char*)strInFile,  startpos, endpos);


**** CToolsStampLib
*** Cache_SealData 缓存支持，依赖 Windows 线程同步对象
*** gLockMutex 跨平台
	D:\codes3\product\SSPDFSign_Server\Code\SSPDFSignServer\A_Tools_Mutex.h
** // 插入文字
	int AddText(int nPageNum, float x1, float y1, float x2, float y2, const char *strText, const char * strFontName, int nFontSize, int nFontGap, int nFontColor, int nBold, int nItalic);
** // 插入图片
	int AddPicture(int nPageNum, float x1, float y1, float x2, float y2, const BYTE * pPicData, int nMask);
** // 验证有效性：签名有效性   印章有效性
	BOOL VerifySign(const char * strSignID, BOOL bOnline = FALSE, char * strErrorInfo = NULL);
** // 搜索文本
	int SearchTextInPage(/* const */ int & nFromPage, const WCHAR * strwSearchString , RECT ** prcMatch, BOOL bText = TRUE, BOOL bIncludeOutline = FALSE, BOOL bIncludeAnnot = FALSE);
	int SearchTextInPage_SearchAllPage(/*const */ int & nPage, const WCHAR * strwSearchString , RECT ** prcMatch,  BOOL bText, BOOL bIncludeOutline, BOOL bIncludeAnnot);
** // 其它：
	string GetSignsInDoc(LONG nIncludeQF = 0);
	string GetSealNameByID(const char * strSignID);
	string GetSealList(void);

	static int ReleaseMemArray(void * pMem);
	static void UseSealListCache(int nUse);

	static void ReleaseResource_DP();

* 2017-06-23 08:43:33 周五 prototype
  # 1. emacs-evil
  # 2. 先跑起来，一个原型，或叫做壳。包括：接口定义、测试用例。
  # 自顶向下，建立空架子；然后填充或替换，封装。
  # 测试程序同时建立
  # 数据结构保留， 数据类型统一定义：Windows, linux, sstypedef.h

* 2017-06-22 08:40:09 周四 理清脉络，各个击破
  # 先跑起来，一个原型，或叫做壳
  # 自顶向下，建立空架子；然后填充或替换，封装。
  # 测试程序同时建立
  # 数据结构保留， 数据类型统一定义：Windows, linux, sstypedef.h
  从接口类入手，找到各个依赖模块和功能单元。
  哪些可以跨平台，哪些需要稍加修改，哪些需要重写。
1. 接口类 CSSPdfDocManager
2. PDF操作类 PDFDoc
3. 缓存类 Cache
4. 线程同步对象 Mutex
5. 印章操作类 CStampManager
6. 图片处理
7. 应用程序信息 GetModuleHandle
8. 动态库加载 LoadDll
9. 签名操作类 SignPdfFile
10. GUID 操作
11. 文件操作 GetFileLength_Win
12. 签名计算 Sign, SignByCert
13. 界面 GUI
14. 其他：插入文字、图片、搜索、释放资源
	# 另外的依赖：压缩zlib、通信curl、
* 2017-06-21 08:36:53 周三 移植、尝试Linux上直接编译 win版SSPDFSignServer
1. 编译主程序文件
2. 编译依赖的库
3. 改写 系统相关的代码， 如 CryptoAPI
afxstd.h 空文件
CryptoAPI 代替文件
# 发现不止是 CryptoAPI 相关代码移植，还有 GDI的依赖。
** 需求文档，功能清单，或者某一个接口头文件
   # 比较功能重写和移植哪个更快？
   CSSPdfDocManager 是对外的接口类，提供所有可用功能。
   # 分析需要移植修改的内容， 移植方法： 替换，修改，重写
* TODO 2017-06-20 08:45:28 周二 新任务：C++dll移植？windows=>linux
1. 调试手写添加的空白签名域
   # 错误提示：无效批注对象。 检查 annotation 相关语法
   1) page /Annots 的数组错误
2. 设计代码添加签名域的功能类
* 2017-06-19 08:44:53 周一，本周目标：成功向PDF中添加签名。
  # 策略 聚焦目标
  移植自定义部分代码：sursen签章，pdf签名。增量更新。参考现有的Windows版程序。
  xpdf 结合 Qt
  交互属性 Signature Fields
1. 用Acrobat编辑一个PDF文件，分析添加签名域的增量更新部分，18个新对象。
2. 编辑PDF文件，手写添加 example 空白签名域。
   # 未成功，提示错误
   1. Info: 5 0 obj<</CreationDate(D:20170616134022+08'00')/ModDate(D:20170619094638+08'00')>>endobj
   2. trailer<</Size 22/Root 7 0 R/Info 5 0 R /Prev 1162>>
   3. AcroForm in Catalog
	  7 0 obj<</Names 8 0 R/Outlines 1 0 R/AcroForm 26 0 R/Pages 2 0 R/Type/Catalog>>endobj
   4. AcroFrom Dictionary
	  26 0 obj<</Fields[30 0 R]>>endobj
   5. Form Field
	  30 0 obj<</FT/Sig/Type/Annot/Rect[185.155 687.001 259.217 719.344]/F 4/T/(Signature1)/AP<</N 42 0 R>>
	  /Subtype/Widget/P 9 0 R>>endobj
   6. Appearance
	  42 0 obj<</Subtype/Form/Length 40/Resources<</ProcSet[/PDF]>>/Type/XObject/BBox[0.0 0.0 74.0621 32.3435]/FormType 1>>
	  stream
	  0.75 1 0.75 rg
	  0 0 74.0621 32.3435 re
	  f
	  endstream
	  endobj
* 2017-06-16 08:46:39 周五
  学习给pdf签名的具体语法：签名信息对象，是一个有18对KV属性的Dictionary。
* 2017-06-15 08:40:48 周四 解决显示和添加
1. 使用 poppler-qt 显示 pdf， 能够显示，但是清晰度有问题。
2. 学习PDF文档格式：概要
* 2017-06-14 08:40:40 周三 xpdf 和 poppler 
  # 两项主要功能：签名计算并生成盖章数据。添加到PDF中，用增量更新。
  “GNU PDF”	GNU GPL	开发中的开源C语言库；完成时会提供实现PDF 1.7规范所有特性的功能。
  （由于Poppler的可用性，2011年10月6日，GNU PDF不再被FSF列为“高优先级计划”。）
  git clone git://git.savannah.gnu.org/pdf.git

  # 编译 poppler 修改libtool编译警告: xxx.la was moved. Qt*.la 中的路径错误。
  # 修改 poppler 头文件路径错误

  # 使用 qt5 显示 pdf
  下一关：向pdf中添加签名域。增量更新。 现有的Windows程序

* 2017-06-13 08:40:29 周二 2017-06-14 08:40:19 sign
  OES_sign ? OES_datasign ? 区别和测试.
  # 查看 windows 版本源码，找到签名使用的接口函数，各部分参数的由来。
  调用印章列表接口

* 2017-06-12 08:52:00 周一  测试印章库so, 调用其中一个函数
1. dlopen, call OES_GetCurrentCerData
  # 可能是缺少某些编译选项
  # dlopen error:../qmake/liboes.so: undefined symbol: asn_DEF_PDU.
2. 调用报错: 10 "have no such file" from GetIniKeyString function
   解决：/opt/sursen/sursen-seal.ini
3. OES_GetCurrentCerData 加载签名库出错
   # 没有找到依赖库
   libssl.so.10 => not found
   libcrypto.so.10 => not found
4. There are 0 SD Card.
   OES_GetCurrentCerData err:20, 获取公钥证书失败
   LoadFTSM2DLL:printf("path:%s,lib:%s, %p\n", szpath,szLibName,SetPIN);

   # 需要 sudo 权限！？
   # 使用硬件key进行签名，扫平各种“坑”
5. 问题： 印章库API的使用方法，需要硬件key， 需要配置文件？ 还有其他前提条件？
   sursen-seal.ini 

\\10.11.16.12\基础产品开发部\高子军\publish\201706_OFD套件\linux\x86_32\sursen

* 2017-06-09 08:35:58 周五 QT两周
** 2017-06-09 10:50:50 java  , linux so
   # 先做添加签名域， 计算签名的功能， 以 so 方式提供给 java调用
http://blog.csdn.net/oh_mourinho/article/details/52691398
Oracle JNI Document
http://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html
1. 编译C++为动态和静态库 so or a
2. 测试环境 JDK 安装
   直接下载jdk压缩包方式安装(这里只介绍jdk7的,jdk8 的原理完全一致)
   分为下面5个步骤
   1.官网下载JDK  jdk-8u131-linux-i586.tar.gz
   2.解压缩,放到指定目录
   3.配置环境变量
   4.设置系统默认JDK
   1. 测试jdk

修改环境变量:　　
sudo vim ~/.bashrc
文件的末尾追加下面内容:

#set oracle jdk environment
export JAVA_HOME=/usr/lib/jvm/jdk1.7.0_60  ## 这里要注意目录要换成自己解压的jdk 目录
export JRE_HOME=${JAVA_HOME}/jre  
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  
export PATH=${JAVA_HOME}/bin:$PATH  

使环境变量马上生效
source ~/.bashrc

测试jdk, 显示版本信息，则成功
java -version

** 学习 Qt 开发 d:/study/Qt/notes.org
http://blog.csdn.net/foruok/article/details/28634543
http://blog.csdn.net/ubuntutouch/article/details/51451757
http://blog.csdn.net/u012419303/article/details/45319249
http://blog.csdn.net/u012419303/article/category/3138565
http://blog.csdn.net/u012419303/article/details/45896263
http://blog.csdn.net/u010002704/article/details/40995797

Qt Quick 简单教程
http://blog.csdn.net/foruok/article/details/28859415
** 练习 widgets + QML
1. 窗口 + 按钮 + ？
2. 按钮点击加载一个图片 signal/slots; event
3. 图片在QML中处理

* 2017-06-08 08:40:15 周四 planning
  学习 Qt 开发 d:/study/Qt/notes.org
  
** DONE 一、开发环境搭建 2D 2017-06-06
1. 32bit and 64bit ubuntu
2. 中文支持（输入法和字体）、emacs编辑器、编译环境（build-essential,xorg-dev,等)
3. linux qt 开发库源码，编译，creator安装
** TODO 二、学习QT开发 10D 2017-06-08
   # QTCore和GUI部分
** 三、学习xpdf源码 10D 2017-06-22
** 四、简易pdf阅读器： xpdf + Qt  10D 2017-07-07
   # 侧栏导航功能，书签等
** 五、移植自定制功能 2017-07-21
*** SurSen签章功能 10D 2017-07-21
*** adobe签名和验签 5D 2017-07-28
** 六、Test自测 2017-07-31

* 2017-06-07 08:41:31 周三 xpdf, podofo
1. 安装和使用 QT
  QT http://wiki.qt.io/Install_Qt_5_on_Ubuntu
2. 编译和使用 poppler(xpdf + qt)
  https://stackoverflow.com/questions/2094253/editing-pdf-with-xpdf-or-with-something-else
  Poppler is a PDF rendering library based on the xpdf-3.03 code base.
   生成 PDF 的C++类库，从xpdf 继承而来。
   https://people.freedesktop.org/~aacid/docs/qt5/
   The Poppler Qt5 interface library, libpoppler-qt5, is a library that allows Qt5 programmers to easily load and render PDF files.  

* 2017-06-06 08:44:01 周二 ubuntu 中编译和使用QT做界面
  # ubuntu + 中文支持 + emacs + 字体 + 编译环境 OK
1. 准备开发环境，安装 32 & 64 位虚拟机，以及相关软件。
   ubuntu32zsl/ununtu64zsl,zsl,try.
2. emacs、中文字体、中文输入法
3. QT 9c8bc8b828c2b56721980368266df9d9  qt-everywhere-opensource-src-5.9.0.tar.xz
2e5609dc9e74525a274beb74cd94ac8e  qt-everywhere-opensource-src-5.9.0.zip
* 2017-06-05 08:30:11 周一 PDF文档编辑 —— 添加签名
** 准备移植到 linux(ubuntu) 系统。 复制
1. 准备开发环境，虚拟机
2. 界面库：QT
3. pdf库：xpdf，sursen定制内容
4. 盖章和签名功能移植： 调用公司现有的签名API，代替Windows的 cryptoAPI.
** Release 版本 Debug
**  # # 给 pdf 添加签名，并附加时间戳属性。问题： 没显示出嵌入时间戳的数据。
  四方面对比：P7签名、时间戳数据、PDF签名域、Reader查看的结果。
1. P7签名，对比结果：签名有效且包含嵌入时间戳。 格式和内容的不同： sha1/detached, md5/sha1, auth_attr(ABSENT/DataType+digest)
2. 时间戳数据对比结果： 正常。 messageDigest和签名不同（因为时间不同）
3. PDF签名域：
   # by adobe
   118 0 obj<</SubFilter/adbe.pkcs7.detached/Location(...二进制数据)/Filter/Adobe.PPKLite/Contents<3082109606092a....
   00000000000000000>/M(D:20170601170845+08'00')/Name(sursen Company)/ByteRange[0 105326 115976 67397 ]
   /Prop_Build<</Filter<</Name/Adobe.PPKLite/R 131101/Date(Dec 14 2004 02:27:38)>>/App<</TrustedMode true/OS[/Win]/Name/Exchange-Pro/R 458752>>
   /PubSec<</R 131101/Date(Dec 14 2004 02:28:36)/NonEFontNoWarn true>>>>/Type/Sig/ContactInfo(13701234565)>>endobj
   # by sursen，有两部分带 /sig
   26 0 obj <<  /AP << /N 25 0 R>>  /DR <</XObject<</FRM 24 0 R>>>>  /F 132  /FT /Sig  /P 6 0 R  /Rect [170.25 601.15 329.25 758.65]
   /Subtype /Widget  /T (7AB94004-0D09-4762-B04C-3641DCC186ED)  /Type /Annot  /V 19 0 R  >> endobj

   19 0 obj <<  /ByteRange [0 49199 69681 22168]                                                                         /ContactInfo (sursen)
   /Filter /Adobe.PPKLite  /Location (beijing)  /Prop_Build <</App<</Name/Adobe.PPKLite>>>>  /Reason (None)  /SubFilter /adbe.pkcs7.sha1
   /Type /Sig /Contents<3082106206092a8648...00000000000> >> endobj
   # 猜测 这个 App<</TrustedMode true/ 属性可能关系
4. Read查看结果：“签名有效”，“签名包含嵌入的时间戳”，问题：未显示时间戳时间
** 设法消除两者之间的差别。是否可以被 adobe-reader 正确识别
1. 尝试修改 CSignature, CSignatureValue
   Prop_Build
   AddKeyValuePair("/Prop_Build", "<</Filter<</Name/Adobe.PPKLite/R 131101/Date(Dec 14 2004 02:27:38)>>/App<</TrustedMode true/OS[/Win]/Name/Exchange-Pro/R 458752>>/PubSec<</R 131101/Date(Dec 14 2004 02:28:36)/NonEFontNoWarn true>>>>");
2. 修改 CSSPDFViewView::TestSignPDF_End， 调整为 detached
   CSSPDFViewView::GetSignData_SignByCert

**  从两个方面查找问题： P7签名 和 pdf文档编辑。 资料
  # podofo:
  http://podofo.sourceforge.net/doc/html/classPoDoFo_1_1PdfSignatureField.html
  # 
  https://stackoverflow.com/questions/39507483/signing-a-pdf-with-adbe-pkcs7-detached
  https://gist.github.com/diorahman/52aa38bdef51b0e5275e
  https://stackoverflow.com/documentation/pdf/5161/integrated-pdf-signatures#t=201609151349146698109
  http://www.adobe.com/devnet-docs/acrobatetk/tools/QuickKeys/Acrobat_SignatureCreationQuickKeyAll.pdf

* 2017-06-02 08:57:03 周五 pkcs7:sha1与detached的区别？
  # 集成代码到PDF。
  # 验证签名中的时间戳，并显示时间戳信息。
  # 添加在 pdf 中的签名时间戳，不能识别问题
  分工： 添加时间戳到 p7签名， 添加签名到pdf文件中。
  PKCS7_add_attribute: 添加 unauth_attr 类型改为 sequence 值还是原来的 octet-string。adobe7可以识别， 最新版Reader 识别不全面
  d2i_ASN1_SEQUENCE_ANY();
  V_ASN1_SEQUENCE
  octet => asn1_type
  openssl 添加 unauth_attr 熟悉
* 2017-06-01 08:44:54 周四 六一儿童节
  http://blog.csdn.net/xiaoniao2003/article/details/51057397
1. 用微软的 cryptoAPI 签名，用 openssl 验证签名。
  # 开始运行中输入certmgr.msc 查看系统已安装的证书
  # windows api 签名处理. Microsoft CryptoAPI
  cryptog.sln
2. pdf 文档的签名(pkcs#7.sha1)是对文档 sha1 摘要的签名，而不是直接拿文档内容做签名。
3. 签名附加时间戳，添加到 pdf 中， adobe 不能识别。

* 2017-05-31 08:45:14 周三 不能拿到证书，必须通过调用系统接口或第三方
** windows api 签名处理. Microsoft CryptoAPI
PCRYPT_TIMESTAMP_CONTEXT tcontext = NULL;
HCERTSTORE hStore = NULL;

fReturn = CryptRetrieveTimeStamp(widestr.c_str(),
       TIMESTAMP_NO_AUTH_RETRIEVAL, 
       0, 
       szOID_NIST_sha256,
       NULL, 
       (const BYTE*)pbMessage, 
       cbMessage, 
       &tcontext, 
       NULL, 
       &hStore);

** pass
1. 测试“以摘要形式传递数据”。 失败：没产生签名。
2. 沟通接口参数： 不能接触到私钥证书， 只能通过Windows系统的接口计算签名或设备提供商的接口
   1. 证书参数的形式（文件路径 or DER字符串 or 解析后的）
   2. 数据参数（字符串？ 范围？摘要？）
   3. 时间戳服务器参数（url，账号）
3. 将代码整理封装为接口，尝试添加到 pdf 中
CSSPDFViewView:
	ON_COMMAND(ID_BUTTON_INSERT_TEXT, OnInsertText)
	ON_COMMAND(ID_BUTTON_INSERT_PICTURE, OnInsertPicture)
  # 验证申请到的时间戳？ 证书文件、证书路径、不信任列表、参数
  # 第三方的证书， 包含在请求响应中？
* 2017-05-27 09:02:32 周六 端午倒班
1. 把时间戳添加到p7签名中 OK
2. 验证：请求时间戳时，tsa证书参数为0时，可否验证通过？ 否
* 2017-05-26 08:23:39 周五
  # 调整时间戳请求参数，验证请求返回值
  # 把时间戳加入pkcs7签名
  # 优化代码，改进无止境。

  # tsa 错误返回测试
  # curl 用户名 密码 and pay
  1. 未提供账号和密码: The requested URL returned error: 401 Unauthorized
  2. 余额不足: The requested URL returned error: 400 Bad Request
** logs
1. 总结: digital-signature, trusted-timestamp, both are signedData of CMS.
   查询p7signeddata中最后一个盲点 OID(1.2.840.113549.1.9.16.2.12)和OID(1.2.840.113549.1.9.16.2.47)
   是 ESS_SIGNING_CERT 的两个版本，目前 openssl 只支持其中第一个。
2. 验证签名OK，开始进行添加签名的功能。查阅签名创建的资料和代码。
3. 创建 p7detached签名OK，完成两个独立的测试程序（签名和验签）
   优化了原有的验证代码。
4. 编译网络库 curl win32版（依赖 openssl, libssl2, zlib)
   构建rfc3161标准的时间戳请求，并用 http 协议从免费的TSA申请时间戳。
* 2017-05-25 08:47:45 周四 
  # curl 编译通过(依赖 openssl, libssl2, zlib)
  https://curl.haxx.se/libcurl/c/curl_easy_setopt.html
  # 学用 curl 进行http请求
  开始申请盖时间戳，网络库是 curl 吗 http,ftp,mime
  # 从免费的TSA申请时间戳 OK
* 2017-05-24 08:37:05 周三 消化整理资料，测试代码
  p7 签名OK 并优化了原有的验证代码。
  完成了 pkcs7 签名以及验签，两个独立测试程序。
  # 编译用到的库 curl
** 基于OpenSSL的时间戳签名和验证
*** 首先自建CA，并生成时间戳签名证书.
	REM 生成CA证书
	openssl req -new -x509 -keyout ca.key -out ca.crt
	REM 生成时间戳签名证书
	openssl genrsa -des3 -out tsakey.pem 1024
	
	REM 去除私钥密码
	openssl rsa -in tsakey.pem -out tsakey.pem
	
	REM 生成证书请求
	openssl req -new -key tsakey.pem -out tsakey.csr
	
	REM extKey.cnf 格式: extendedKeyUsage = critical,timeStamping
	
	REM 使用扩展用法文件签署时间戳签名证书
	openssl x509 -req -days 730 -in tsakey.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out tsakey.crt -extfile extKey.cnf
*** 根据数据文件test.txt生成时间戳签名请求
	openssl ts -query -data test.txt -no_nonce -out design1.tsq
*** 使用时间戳证书签署请求，生成签名值
	openssl ts -reply -queryfile design1.tsq -inkey tsakey.pem -signer tsakey.crt -out design1.tsr
*** 使用CA证书和时间戳签名证书验证时间戳签名值
	openssl ts -verify -queryfile design1.tsq -in design1.tsr -CAfile ca.crt -untrusted tsakey.crt
*** 使用原文验证时间戳
	openssl ts -verify -data test.txt -in design1.tsr -CAfile ca.crt

* 2017-05-23 08:41:46 周二 给pdf文档加带时间戳的签名
# 创建 adobe.pkcs7.detached 签名,并盖时间戳
1. 创建 p7 签名, 参考命令行工具
2. 添加时间戳
** 四日 完工并测试
** 三日 编写代码或继续寻找，或研读标准
** 次日 消化整理资料，测试代码
** 首日 互联网收集资料和源码

# CURL 进行网络请求
   https://curl.haxx.se/libcurl/c/example.html
C:\Users\zsl\AppData\Local\bin\NASM
path = %PATH%;c:\nsam
mkdir c:/openssl

C#
using (Document document = new Document(@"c:\your_file.pdf"))
{
    using (PdfFileSignature signature = new PdfFileSignature(document))
    {
       PKCS7 pkcs = new PKCS7(@"c:\your_pfx.pfx", "pfx_password");
       TimestampSettings timestampSettings = new TimestampSettings("https:\\your_timestamp_settings", "user:password"); // User/Password can be omitted
       pkcs.TimestampSettings = timestampSettings;
       System.Drawing.Rectangle rect = new System.Drawing.Rectangle(100, 100, 200, 100);
       // Create any of the three signature types
       signature.Sign(1, "Signature Reason", "Contact", "Location", true, rect, pkcs);
       // Save output PDF file
       signature.Save(@"c:\test_out.pdf");
    }
}

# 需要证书 C:\Users\zsl\AppData\Roaming\Adobe\Acrobat\7.0\Security\
# pfx (pkcs#12) 证书的保护口令: sursen.
签名数据的产生过程有如下几步：
1. 对于每一个签名者，他用消息摘要算法计算出摘要值 。
2. 对于每一个签名者，消息摘要和相关的信息用自己的私钥加密。
3. 对于每一个签名者，把加密的消息摘要和其他的签名者特定信息放入signer_info值中。
   每个 签名者的证书、crl等也在这一步被收集进来。
4. 把所有签名者的信息摘要算法、他们的signer_info值和内容一起放进sign值中。
   # 何时插入时间戳
5. 构建时间戳请求
6. 发生请求给TSA
7. 验证响应
8. 添加到pkcs7签名中

Q: signedData 这获取的证书链stack 为啥数量都是 1？
STACK_OF(X509) *certs = PKCS7_get0_signers(pkcs7, 0, flags);
A:此函数类似 X509 *cert= PKCS7_cert_from_signer_info(pkcs7, si);
是收集所有签名者的证书，因为只有一个签名者，所以只找到一份证书。

* 2017-05-22 08:52:28 第6周 周一
  # 回顾总结： digital-signature, trusted-timestamp, openssl
概念： digital-signature, trusted-timestamp，两者都是一份带签名的数据。
pkcs7SignedData 中最后一个盲点：
signedData d.sign中certs 以及 signer_info 中的signingCertificate，相同？no
OID(1.2.840.113549.1.9.16.2.12)和OID(1.2.840.113549.1.9.16.2.47)
结果：
d.sign中的certs是X509证书链; signer_info中的signingCertificate是ESS_SIGNING_CERT.
ESS:"Enhanced Security Services for S/MIME" RFC2634


id-smime-aa-signingCertificate (1.2.840.113549.1.9.16.2.12)
id-smime-aa-signingCertificateV2 (1.2.840.113549.1.9.16.2.47)
ts.rsp.sign.c: ESS_add_signing_cert(si, ESS_SIGNING_CERT *sc)
static ESS_SIGNING_CERT *ess_get_signing_cert(PKCS7_SIGNER_INFO *si)
ESS:"Enhanced Security Services for S/MIME", RFC2634

* 2017-05-19 08:39:23 周五
** 内存检查，重新编译 openssl
** 获取和展示 signer_info.issuer_and_serial
** logs
1. 重新计算的hash与下面之一对应上了，但并不清楚其中含义。
   搞清楚，第二个 id-smime-ct-TSTInfo 域中的 messageDigest 和第一个 id-smime-ct-TSTInfo 域中的messageImprint是如何计算的。
2. 尝试利用 openssl 命令行工具，研究签名和时间戳的每个步骤。
3. 再读标准 rfc3161和2630 以及 GBT20520-2006，搞清楚时间戳的asn1数据构造。
4. 解决不同的摘要算法 sha1/ sha256 程序没有识别问题。
   TSTInfo 中的 messageImprint 用于验证盖时间戳的内容
   signerinfo.auth_attr中的 messageDigest 用于验证时间戳本身
5. 梳理文档，整理代码，添加注释。
   验证时间戳的三个主要步骤：验证cert、验证TSTinfo、验证数据。成功完成后两项。
   第一项需要链接CA和TSA机构网站，获取证书链和CRL，后续再做。
   重新编译 openssl 添加内存检查函数
* 2017-05-18 08:56:05 周四 未完待续
  # 经验教训：仔细阅读文档，顺藤摸瓜。尤其是官方文档和标准。
  搞定了 OID(1.2.840.113549.1.9.16.2.14)
google : pdf pkcs#7.detached 签名中的时间戳，使用的哪些内容进行的 hash？
A: 通过阅读 pdf-reference->rfc3161 得到了答案。
before google : review 代码，最好讲解；
# 梳理文档，查看是否有其他 bug ？ 添加代码注释
https://tools.ietf.org/html/rfc3852 CMS
https://tools.ietf.org/html/rfc2315 PKCS#7
https://tools.ietf.org/html/rfc3161 TSP
https://tools.ietf.org/html/rfc2630 CMS

TSTInfo 中的 messageImprint 用于验证盖时间戳的内容
signerinfo.auth_attr中的 messageDigest 用于验证时间戳本身

  # 解决不同的摘要算法 sha1/ sha256 程序没有识别不同？
  # sha1 算法的摘要对应上了，但是 时间戳信息中的摘要没有对应

* 2017-05-17 08:24:52 周三 在读标准 rfc3161/2630 和对应 GB 
  # 搞清楚时间戳的asn1数据构造
  # 遇到了 不同的摘要算法 sha1, sha256 程序没有识别不同？
  # sha1 算法的摘要对应上了，但是 时间戳信息中的摘要没有对应
  STACK_OF(X509)signers= *PKCS7_get0_signers(Pkcs7);
  if ((store = setup_verify(CAfile, CApath, noCAfile, noCApath)) == NULL)
  goto end;
  X509_STORE_set_verify_cb(store, smime_cb);
  sk_X509_free(signers);
  
  STACK_OF(X509_ALGOR) *PKCS7_get_smimecap(PKCS7_SIGNER_INFO *si);
  
  int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx,
  BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si);
  int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,
  X509 *x509);
  int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,
  
* 2017-05-16 08:39:41 周二
http://stackoverflow.com/questions/19528456/verify-rfc-3161-trusted-timestamp
http://blog.csdn.net/as3luyuan123/article/details/16867849
努力弄清楚验证步骤的每个细节

# 基于OpenSSL的时间戳签名和验证 begin
2014-03-31 23:17 2252人阅读 评论(0) 收藏 举报

首先自建CA，并生成时间戳签名证书.
REM 生成CA证书
openssl req -new -x509 -keyout ca.key -out ca.crt
REM 生成时间戳签名证书
openssl genrsa -des3 -out tsakey.pem 1024

REM 去除私钥密码
openssl rsa -in tsakey.pem -out tsakey.pem

REM 生成证书请求
openssl req -new -key tsakey.pem -out tsakey.csr

REM extKey.cnf格式: extendedKeyUsage = critical,timeStamping

REM 使用扩展用法文件签署时间戳签名证书
openssl x509 -req -days 730 -in tsakey.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out tsakey.crt -extfile extKey.cnf
根据数据文件test.txt生成时间戳签名请求
openssl ts -query -data test.txt -no_nonce -out design1.tsq
使用时间戳证书签署请求，生成签名值
openssl ts -reply -queryfile design1.tsq -inkey tsakey.pem -signer tsakey.crt -out design1.tsr

使用CA证书和时间戳签名证书验证时间戳签名值
openssl ts -verify -queryfile design1.tsq -in design1.tsr -CAfile ca.crt -untrusted tsakey.crt

使用原文验证时间戳
openssl ts -verify -data test.txt -in design1.tsr -CAfile ca.crt
# 基于OpenSSL的时间戳签名和验证 end


利用 openssl 命令行工具，研究签名和时间戳的每个步骤。
https://d-mueller.de/blog/dealing-with-trusted-timestamps-in-php-rfc-3161/
We do some verification of our parameters and then mess around with return-codes from the openssl ts-command to see if our hash is still valid when checking against our Timestamp Response. We also check, if the unix timestamp of signing is still the same. It’s important to mention that we need the certificate chain (usually pem-format) of the TSA. Our method expects the path to the certificate-file in the last parameter. 
"openssl ts -verify -digest "the hash" -in "TSA response" -CAfile "tsa_cert_file""
https://pki.pca.dfn.de/global-services-ca/pub/cacert/chain.txt

OpenSSL 主配置文件 openssl.cnf http://www.cnblogs.com/f-ck-need-u/p/6091027.html

* 2017-05-15 08:45:50 第5周 周一 验证时间戳及盖戳的文档
1. X509_verify_cert OpenSSL: unable to get local issuer certificate

2. 待解决问题： 忽略这个警告。
   X509_STORE_CTX_get_error is 19
   "self signed certificate in certificate chain"

# 确定 pdf p7签名中时间戳所使用的内容是哪部分？ 同 p7签名使用的文档内容范围。
   计算的到的摘要对应于 id-smime-aa-timeStampToken 第二个 id-smime-ct-TSTInfo 域中的 messageDigest.
   TS_TST_INFO 中得到的是第一个 id-smime-ct-TSTInfo 域中的内容？

* 2017-05-12 08:36:18 对照时间戳验证步骤，进行编码实现
** logs
1. 购买了一个时间戳，用在线工具进行签名和验证测试。
   对比免费时间戳和验证通过的时间戳的区别。
   # 搜索文档，参考源码，整理时间戳服务详细流程。
2. 参考openssl源码，尝试时间戳验证编码。时间戳信息提取，待续。
   # 待解决问题：自签名证书验证失败。
   # X509_STORE_CTX_get_error is 19 "self signed certificate in certificate chain"
3. 查阅更多资料，并对照测试代码导出的 TS-token，基本看通了《RFC3161》《RFC2630》
4. 阅读《openssl编程》，更全面的了解openssl各个组件和编程方式。
5. 得到了 id-smime-aa-timeStampToken 域中的两个 digest 信息。
   对照时间戳验证流程梳理试验代码。
** 确定 pdf 时间戳所使用的内容是哪部分？
   计算的到的摘要对应于 id-smime-aa-timeStampToken 第二个 id-smime-ct-TSTInfo 域中的 messageDigest.
   TS_TST_INFO 中得到的是第一个 id-smime-ct-TSTInfo 域中的未解码内容？
**  时间戳服务的详细流程：
   盖时间戳：
   (1) 对欲发送的文件做Hash得到消息摘要
   (2) 将消息摘要发送给TSA
   (3) TSA把 (消息摘要+当前时间)—> Hash = 带有时间戳的消息摘要的hash值
   (4) 将带有时间戳的消息摘要hash值 用TSA的私钥加密
   (5) 将 私钥加密后的数据 + 明文时间 (就是第3步的那个“当前时间”) 返回给用户A
   时间戳验证：
   (1) 用户B收到了用户A加入了TSA私钥加密的消息时间摘要的消息，把这个TSA时间戳拿出来(涉及其他解密，这里略去)
   (2) 接下来这步在我们个人的简易实现里是没有的： 将TSA私钥加密的消息时间摘要重新发回TSA验证此摘要真实性。
   (3) 验证真的是那个TSA发布的，然后就拿TSA的公钥对 "TSA私钥加密的消息时间摘要"中的“私钥加密后的数据”进行解密，明文时间留着备用
   (4) 解密完得到“带有时间戳的消息摘要的hash值”(标准值)
   (5) 使用收到的文件解密完再次hash得到消息摘要
   (6)  (消息摘要+当前时间)—> Hash = 带有时间戳的消息摘要的hash值 (验证值)
   (7) 标准值 ?= 验证值 可以验证消息是否受到重放攻击等

* 2017-05-11 08:40:40 周四 继续阅读资料，或调试程序
  # 阅读《openssl编程》.pdf
  # 根据从新资料中学到的，分析和优化代码
* 2017-05-10 08:50:40 周三 继续
** 配置了开发环境的历史纪录功能，安装了插件 Visual Assist
** DONE 资料整理和系统学习
   查阅Openssl开发相关资料，对照导出的 timestamp token,
   再读《RFC3161》，嵌套了《RFC2630》，对照 openssl 源码，坚冰融化。
   # 同时接触多项新技术： pdf格式、数字签名、openssl、
** 查资料、编码尝试、查资料、代码整理...
* 2017-05-09 08:35:29 周二
# 待解决问题： X509_STORE_CTX_get_error is 19 "self signed certificate in certificate chain"
  int result= TS_RESP_verify_signature(Pkcs7, STACK_OF(X509) *certs,
  X509_STORE *store, X509 **signer_out)

  # 验证时间戳 int_ts_RESP_verify_token
  TS_VERIFY_CTX *TS_REQ_to_TS_VERIFY_CTX(TS_REQ *req, TS_VERIFY_CTX *ctx);
  从 response 中得到 request，再用上述函数创建 ctx

  # 时间戳验证：5，6，，，未完待续

The code we use to call PKCS7_verify() is essentially something like this:

PKCS7* p7 = d2i_PKCS7_bio(pkcs7Bio, NULL); // pkcs7Bio is a BIO reading from the pkcs7Blob file
X509_STORE* rootStore = X509_STORE_new();
X509_STORE_add_cert(rootStore, rootCACert); // rootCACert is an X509* read from the "RootCA.pem" file
BIO* contentDataBio = BIO_new(BIO_s_mem());
X509_VERIFY_PARAM_set_flags(X509_STORE_get0_param(rootStore), X509_V_FLAG_CB_ISSUER_CHECK);
X509_STORE_set_verify_cb(rootStore, acceptExpiredCertsVerificationCallback); // acceptExpiredCertsVerificationCallback essentially just ignores X509_V_ERR_CERT_HAS_EXPIRED errors
X509_STORE_set_purpose(rootStore, X509_PURPOSE_ANY);
PKCS7_verify(p7, NULL, rootStore, NULL, contentDataBio, 0 ); // fails with "unable to get local issuer certificate" in 1.1.0c, succeeds in 1.0.2j

1. 验证pdf文档时间戳
Q:
debug:X509_STORE_CTX_get_error is 19.
 "self signed certificate in certificate chain"
A:
You have a certificate which is self-signed, so it's non-trusted by default, that's why OpenSSL complains.
This warning is actually a good thing, because this scenario might also rise due to a man-in-the-middle attack.
To solve this, you'll need to install it as a trusted server.
If it's signed by a non-trusted CA, you'll have to install that CA's certificate as well.
Have a look at this link about installing self-signed certificates.
A2:
At some level, a self-signed certificate will always appear in a certificate chain
 - most notably the case with CA certs, which are by definition self-signed, but are trusted.
 You are seeing that message because the StartSSL CA cert is self-signed.
Your chain file is also wrong - you don't need the client certificates.
 The file should be in the following order, from the top of the file to the bottom,
 links are to StartSSL's equivalent cert, assuming class 2 validation (documentation is here):

Private key (optional)
Your Public certificate
Class 2 Intermediate Certificate
Root CA certificate
Your error could be down to using the wrong port, as discussed here.
 For reference, port 995 is used for POP SSL connections, port 993 is used for IMAP SSL (reference).

* 2017-05-08 08:55:29 第4周 周一
  时间戳服务的详细流程：
   盖时间戳：
   (1) 对欲发送的文件做Hash得到消息摘要
   (2) 将消息摘要发送给TSA
   (3) TSA把 (消息摘要+当前时间)—> Hash = 带有时间戳的消息摘要的hash值
   (4) 将带有时间戳的消息摘要hash值 用TSA的私钥加密
   (5) 将 私钥加密后的数据 + 明文时间 (就是第3步的那个“当前时间”) 返回给用户A
   时间戳验证：
   (1) 用户B收到了用户A加入了TSA私钥加密的消息时间摘要的消息，把这个TSA时间戳拿出来(涉及其他解密，这里略去)
   (2) 接下来这步在我们个人的简易实现里是没有的： 将TSA私钥加密的消息时间摘要重新发回TSA验证此摘要真实性。
   (3) 验证真的是那个TSA发布的，然后就拿TSA的公钥对 "TSA私钥加密的消息时间摘要"中的“私钥加密后的数据”进行解密，明文时间留着备用
   (4) 解密完得到“带有时间戳的消息摘要的hash值”(标准值)
   (5) 使用收到的文件解密完再次hash得到消息摘要
   (6)  (消息摘要+当前时间)—> Hash = 带有时间戳的消息摘要的hash值 (验证值)
   (7) 标准值 ?= 验证值 可以验证消息是否受到重放攻击等
1. 搜索并参考其他源代码，尝试时间戳的验证。
2. 购买了一个时间戳，测试签名和验证：对比免费时间戳和验证通过的时间戳的区别。
3. d:/study/CryptTs.c L522
* 2017-05-05 08:40:57 周五
1 整理代码(z_xpdf.hpp, z_pkcs7.hpp)，显示时间戳信息
  prim object : signingTime, prim UTCTIME : 170426064059Z
  memcpy();
2 测试
3 尝试另一种解析方式： asn1 Or stack
4 查阅验签的更多资料，做到更好，既实现功能又知道原理
看标准、读源码、定制函数
* 2017-05-04 08:34:23 周四
1. 自己定制一个asn1sequence的解析函数
   # 成果 int asn1_parse2
   asn1_parse2_dbg: d:/asn1dump
   unauth_attr:
   object: id-smime-aa-timeStampToken (1.2.840.113549.1.9.16.2.14)
   set:
   av = PKCS7_get_attribute(signInfo, NID_id_smime_aa_timeStampToken);
   NID_id-smime-aa-timeStampToken
   # 以上是 asn1 解析方式
2. # define PKCS7_get_attributes(si)        ((si)->unauth_attr)

   STACK_OF(X509_ATTRIBUTE) *unauth_attr; /* [ 1 ] */
   # define STACK_OF(type) struct stack_st_##type

   typedef struct x509_attributes_st X509_ATTRIBUTE;
   DEFINE_STACK_OF(X509_ATTRIBUTE)

   /* a sequence of these are used */
   struct x509_attributes_st {
     ASN1_OBJECT *object;
     STACK_OF(ASN1_TYPE) *set;
   };
   
	int skn=sk_X509_ATTRIBUTE_num(attrs);
	X509_ATTRIBUTE *attr=sk_X509_ATTRIBUTE_value(attrs, 0);

   int X509_ATTRIBUTE_count(const X509_ATTRIBUTE *attr);
   ASN1_OBJECT *X509_ATTRIBUTE_get0_object(X509_ATTRIBUTE *attr);得到attr->object
   ASN1_TYPE *X509_ATTRIBUTE_get0_type(X509_ATTRIBUTE *attr, int idx);得到attr->set
   # 另一种实现方式， st->object, st->set, st_functions...
* 2017-05-03 08:33:24 周三
1. 获取PDF签名的时间戳信息（规范和代码）
   国际电子时戳标准规范《RFC3161》
   《RTF2630》Cryptographic Message Syntax.
   《GB/T20520-2006 信息安全技术-公钥基础设施-时间戳规范》
   # pkcs#7 时间戳的格式
   对比指针移动的长度，和返回的数据长度，附加信息， 获知如何移动到下一个数据项。
   # 时间戳验证： 计算摘要，与时间戳中的时间进行计算， 对比时间戳中的签名。
2. 跟踪 openssl 源码
PKCS7_print_ctx(out, p7, 0, NULL);
ASN1_item_print(out, (ASN1_VALUE *)p7, indent, ASN1_ITEM_rptr(PKCS7), pctx);
: PKCS7_print_ctx(out, p7, 0, NULL);
1. IMPLEMENT_ASN1_PRINT_FUNCTION(PKCS7)
   1. IMPLEMENT_ASN1_PRINT_FUNCTION_fname(stname, stname, stname)
	  1. int fname##_print_ctx(BIO *out, stname *x, int indent, const ASN1_PCTX *pctx) \
         { \
         return ASN1_item_print(out, (ASN1_VALUE *)x, indent, ASN1_ITEM_rptr(itname), pctx); \
         }
ASN1_ITEM_rptr(PKCS7)

# 成果 int asn1_parse2
  asn1_parse2_dbg: d:/asn1dump


ASN1_TYPE *PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
    return (get_attribute(si->auth_attr, nid));
}

ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
    return (get_attribute(si->unauth_attr, nid));
}

* 2017-05-02 08:51:45 周二
1. 查阅pdf签名，时间戳的相关标准 (pdfspec,pkcs#7,ASN.1,DER,X.509,TSA)
2. 搜寻openssl源码，获取时间戳信息的方法
   时间戳编码规范 http://www.ietf.org/rfc/rfc3161.txt
【ASN.1定义的基本数据类型】[数据类型] -- [数据说明] -- [Tag(16进制)] 
# 思路 X509_ATTRIBUTE *attr=sk_X509_ATTRIBUTE_value(attrs, 0);
attr => ts  是否可以直接转为时间戳封装的格式
时间戳的信息： 时间、摘要
* 第3周 周一 五一劳动节
* 2017-04-28 08:40:19 周五
1. 分析 pkcs7 格式，获取时间戳信息

* 2017-04-27 08:38:08 周四
1. 分析 pkcs7 格式，获取时间戳信息
   # define STACK_OF(type) struct stack_st_##type
   typedef struct x509_attributes_st X509_ATTRIBUTE;
   STACK_OF(X509_ATTRIBUTE) : stack_st_X509_ATTRIBUTE
   
   int OPENSSL_sk_num(const OPENSSL_STACK *);
   void *OPENSSL_sk_value(const OPENSSL_STACK *, int);

   asn1_item_print_ctx
   时间戳在 signer_info 中？

   # java
   ASN1InputStream tempstream = new ASN1InputStream(
   new ByteArrayInputStream(respBytes));
   ASN1EncodableVector unauthAttributes = new ASN1EncodableVector();
   
   // time Stamp token : id-aa-timeStampToken da RFC3161, alias old
   // id-smime-aa-timeStampToken
   ASN1EncodableVector v = new ASN1EncodableVector();
   v.add(new DERObjectIdentifier("1.2.840.113549.1.9.16.2.14")); // id-aa-timeStampToken
   
   ASN1Sequence seq = (ASN1Sequence) tempstream.readObject();
   DERObject timeStampToken = (DERObject) seq.getObjectAt(1);
   v.add(new DERSet(timeStampToken));
   //               v.add(new DERSet(seq));
   
   unauthAttributes.add(new DERSequence(v));
   return unauthAttributes;

2. pdf 工具
* 2017-04-26 09:00:37 周三
** job
1. 取时间戳信息：
   # token = d2i_PKCS7_bio(in_bio, NULL);
   TS_TST_INFO *PKCS7_to_TS_TST_INFO(PKCS7 *token);

   # PKCS7_get_attributes(pkcs7_signer_info_st/PKCS7_SIGNER_INFO)
   STACK_OF(X509_ATTRIBUTE) *auth_attr = PKCS7_get_attributes(sk);

2. 试验免费的时间戳服务
3. 模拟实现时间戳服务器？
4. mmc 管理时间戳服务器的证书
5. 查找“时间戳服务器”

** study
   X509是基本规范
   P7和P12是两个实现规范，P7是数字信封，P12是带有私钥的证书规范。
   
   x509是数字证书的规范，P7和P12是两种封装形式。比如说同样的电影，有的是avi格式，有的是mpg，大概就这个意思。
   P7一般是把证书分成两个文件，一个公钥一个私钥，有PEM和DER两种编码方式。PEM比较多见，就是纯文本的，P7一般是分发公钥用，看到的就是一串可见字符串，扩展名经常是.crt,.cer,.key等。DER是二进制编码。
   P12是把证书压成一个文件，.pfx 。主要是考虑分发证书，私钥是要绝对保密的，不能随便以文本方式散播。所以P7格式不适合分发。.pfx中可以加密码保护，所以相对安全些。
   在实践中要中，用户证书都是放在USB Key中分发，服务器证书经常还是以文件方式分发。服务器证书和用户证书，都是X509证书，就是里面的属性有区别。
   
   X509 是证书规范
   PKCS#7 是消息语法 （常用于数字签名与加密）
   PKCS#12 个人消息交换与打包语法 （如.PFX .P12）打包成带公钥与私钥
   还有其它常用的是PKCS#10 是证书请求语法。

* 2017-04-25 08:50:38 周二
1. pdf reference sub-clause: 文件结构
   测试用 cross-reference table 中的地址，对pdf文件中的对象进行随机访问。
2. xpdf 源码: 部分
3. 演示和移交代码
* 2017-04-24 09:59:55 第2周 周一
1. 提取签名信息。
2. 整理PKCS7.detached验签代码。
3. pdf reference sub-clause: 概要，词汇，对象，过滤器
4. 尝试查找 xpdf 读取内容失败的原因
* 2017-04-21 10:53:55 创建 pdf 文档并签名
C:\Users\zsl\AppData\Roaming\Adobe\Acrobat\7.0\Security\zsl.pxf
重构和测试

* 2017-04-20 09:08:05 plan
** DONE openssl windows上编译安装
"D:\Program Files (x86)\Microsoft Visual Studio 8\VC\bin\nmake" 启动VS的命令行窗口
D:\opensource\openssl-1.1.0e>perl Configure --debug VC-WIN32 no-asm no-async no-threads
** DONE pdf: xpdf, get ByteRange and sig Contents
void CSSPDFViewView::OnViewZslTest()
{
	char * strFileName = GetCurrentDocFile();

	DocDisplayAttrb *  pdda = GetDocDisplayAttrib();
	if(!pdda)
		return;		


	char ss[10240]={0};
	pdda->verifyName(ss);

	MessageBox(ss);
}

void DocDisplayAttrb::verifyName(char *ss){
	XRef *xref = doc->getXRef();
	if(!xref) return;

	Object obj, o2;
	const char *s=0;
	char buf[1024]={0};
	unsigned range[4]={0};

	xref->fetchFromOrigContent(113, 0, &obj, 0); 

	// xref->getNumObjects();
	if(obj.isDict()) {
		Dict *dic =  obj.getDict();
		int l = dic->getLength();
		sprintf(ss, "dict length:%d, Key...:", dic->getLength());
		for(int i=0;i<l; ++i) {
			s = dic->getKey(i);
			strcat(ss, s);
			strcat(ss, " : ");
			if(strcmp(s, "ByteRange")==0){
				dic->getVal(i, &o2);
			    strcat(ss, o2.getTypeName());
				strcat(ss, " : ");
				Array *ar = o2.getArray();
				for(int j=0; j<ar->getLength(); ++j){
					ar->get(j, &o2);
					strcat(ss, o2.getTypeName());
					range[j] = o2.getInt();
					sprintf(buf," %d", range[j]);
					strcat(ss, buf);
					strcat(ss, ",");
				}
			}else if(strcmp(s, "Contents") ==0){
				dic->getVal(i, &o2);
			    strcat(ss, o2.getTypeName());
				GString *gs = o2.getString();
				//strcat(ss, gs->getCString());
				FILE *pf = fopen("d:/tmp1", "wb");
				fwrite(gs->getCString(), sizeof(char), gs->getLength(), pf);
				fclose(pf);
				sprintf(buf," %u", gs->getLength());
				strcat(ss, buf);
			}
			strcat(ss, "\n");
		}
		
	}
	FILE *pfr = fopen(doc->getFileName()->getCString(), "rb");
	FILE *pfw = fopen("d:/other", "wb");
	char *tmpb = new char[range[1]];
	int rl = fread(tmpb, sizeof(char), range[1], pfr);
	fwrite(tmpb, sizeof(char), rl, pfw);
	delete [] tmpb;
	
	fseek(pfr, range[2], 0);
	tmpb = new char[range[3]];
	rl = fread(tmpb, sizeof(char), range[3], pfr);
	fwrite(tmpb, sizeof(char), rl, pfw);
	delete [] tmpb;

	fclose(pfr);
	fclose(pfw);
}

** TODO DER-encoded => pkcs7 info
$ openssl pkcs7 -inform DER -in d:/tmp1

void zsl2(const unsigned char *in, long len)
{
	int der = 1; /* Input from DER or PEM ? */
	int text = 1; /* Dump text or output PEM ? */

	PKCS7 *p7 = NULL;

	p7 = d2i_PKCS7(&p7,&in,len);


	if (p7 == NULL) {
		printf("unable to load PKCS7 object\n");
		goto end;
	}

	
	//获得签名者信息stack
	STACK_OF(PKCS7_SIGNER_INFO) *sk = PKCS7_get_signer_info(p7);

	//获得签名者个数(本例只有1个)
	int signCount = sk_PKCS7_SIGNER_INFO_num(sk );

	BIO *p7bio= PKCS7_dataDecode(p7,NULL,NULL,NULL); // 没有

	for(int i=0;i<signCount;++i) {
		//获得签名者信息
		PKCS7_SIGNER_INFO *signInfo = sk_PKCS7_SIGNER_INFO_value(sk,i);

		//获得签名者证书
		X509 *cert= PKCS7_cert_from_signer_info(p7, signInfo);

		// 同上 cert = = x
		//int	j = OBJ_obj2nid(p7->type);
		//STACK_OF(X509) *certs = NULL;
		//if(j == NID_pkcs7_signed) {
		//	certs = p7->d.sign->cert;
		//} else if(j == NID_pkcs7_signedAndEnveloped) {
		//	certs = p7->d.signed_and_enveloped->cert;
		//}
		//int cn = sk_X509_num(certs);
		//for (i = 0; certs && i < cn; i++) {
		//	X509 *x = sk_X509_value(certs,i);
		//	printf("%x", x);
		//}

		const int flen = 1024*300;
		char all[flen]={0};
		FILE *pfr = fopen("d:/other", "rb");
		int len = fread(all, sizeof(char), flen, pfr);
		fclose(pfr);

BIO* p7bio = PKCS7_dataInit(p7, NULL);
BIO_write(p7bio, all, len);//加入原始数据，
PKCS7_dataFinal(p7, p7bio); //处理数据。

		int x=1;
		// 验证签名
		if(PKCS7_signatureVerify(p7bio, p7, signInfo, cert) != 1){
			printf("signatureVerify Err\n");
		}
	}


	//int	i = OBJ_obj2nid(p7->type);
	//STACK_OF(X509) *certs = NULL;
	//if(i == NID_pkcs7_signed) {
	//	certs = p7->d.sign->cert;
	//} else if(i == NID_pkcs7_signedAndEnveloped) {
	//	certs = p7->d.signed_and_enveloped->cert;
	//}

	//BIO *out = BIO_new(BIO_s_file());
	//BIO_set_fp(out, stdout, BIO_NOCLOSE);
	//for (i = 0; certs && i < sk_X509_num(certs); i++) {
	//	X509 *x = sk_X509_value(certs,i);
	//	if(text) {
	//		X509_print(out, x);
	//	} else {
	//		PEM_write_bio_X509(out,x);
	//	}
//	}

end:
	PKCS7_free(p7);


}

int _tmain(int argc, _TCHAR* argv[])
{
	int l = 3584;
	l /= 4;
	printf("unsigned:%d, char %d, len:%d", sizeof(unsigned), sizeof(char), l);

//	zsl("d:/tmp1");

	FILE* pf = fopen("d:/tmp1", "rb");
	unsigned char buf[4096]={0};
	//fseek(pf, 105084,0);
	size_t len = fread(buf, 1, 3584, pf);
	fclose(pf);
	printf("file read :%d\n", len);

	zsl2(buf, len);

** verify signature

* VS C++ 使用 openssl Libs
右击工程名 —— 属性 —— 配置属性
1) C/C++： 附加包含目录 ——  新增"d:\openssl\include"(存放编译后的库文件的目录中)
C:\Program Files (x86)\OpenSSL\include
2) 链接器： 附加库目录 -- 新增"d:\openssl\lib"
C:\Program Files (x86)\OpenSSL\lib
3) 调试： 环境 -- 添加 PATH=C:\Program Files (x86)\OpenSSL\bin
   合并环境变量：是
PATH=C:\Program Files (x86)\OpenSSL\bin;D:\codes\curl\lib
* 2017-04-19 10:38:56 pdf reference 摘录
When PKCS#7 signatures are used, the value of Contents is a DER-encoded PKCS#7 binary data object containing the signature.
The PKCS#7 object must conform to the PKCS#7 specification in Internet RFC 2315, PKCS #7: Cryptographic Message Syntax, Version 1.5

For byte range signatures, Contents is a hexadecimal string with “<” and “>” delimiters.

It must fit precisely in the space between the ranges specified by ByteRange. 

Since the length of PKCS#7 objects is not entirely predictable, it is often necessary to pad the value of Contents with zeros at the end of the string (before
the “>” delimiter) before writing the PKCS#7 to the allocated space in the file.
The most common format for encoding signature values is adbe.pkcs7.detached. This encoding allows the most options in terms of algorithm use.

Hexadecimal Strings
Strings may also be written in hexadecimal form, which is useful for including arbitrary binary data in a PDF file.
A hexadecimal string is written as a sequence of hexadecimal digits (0–9 and either A–F or a–f) enclosed within angle brackets (< and >):
< 4E6F762073686D6F7A206B6120706F702E >

Each pair of hexadecimal digits defines one byte of the string.
White-space characters (such as space, tab, carriage return, line feed, and form feed) are ignored.

If the final digit of a hexadecimal string is missing — that is, if there is an odd number of digits—the final digit is assumed to be 0.
For example:
< 901FA3 >
is a 3-byte string consisting of the characters whose hexadecimal codes are 90, 1F, and A3, but
< 901FA >
is a 3-byte string containing the characters whose hexadecimal codes are 90, 1F, and A0.

* massapi java
 public VerificationResult verify(final String aFileName, byte[] aPassword) {
    final VerificationResult tmpResult = new VerificationResult();
    try {
      final PdfReader tmpReader = getPdfReader(aFileName, aPassword);

      final AcroFields tmpAcroFields = tmpReader.getAcroFields();
      final ArrayList<String> tmpNames = tmpAcroFields.getSignatureNames();
      tmpResult.setTotalRevisions(tmpAcroFields.getTotalRevisions());

      for (String name : tmpNames) {
        final SignatureVerification tmpVerif = new SignatureVerification(name);
        tmpVerif.setWholeDocument(tmpAcroFields.signatureCoversWholeDocument(name));
        tmpVerif.setRevision(tmpAcroFields.getRevision(name));
        final PdfPKCS7 pk = tmpAcroFields.verifySignature(name);
        tmpVerif.setDate(pk.getSignDate());
        tmpVerif.setLocation(pk.getLocation());
        tmpVerif.setReason(pk.getReason());
        tmpVerif.setSignName(pk.getSignName());
        final Certificate pkc[] = pk.getCertificates();
        final X509Name tmpX509Name = PdfPKCS7.getSubjectFields(pk.getSigningCertificate());
        // TODO read more details from X509Name ?
        tmpVerif.setSubject(tmpX509Name.toString());
        tmpVerif.setModified(!pk.verify());
        // TODO revocation list and date to which should be verified?
        tmpVerif.setFails(PdfPKCS7.verifyCertificates(pkc, kall, null, tmpVerif.getDate()));
        tmpResult.addVerification(tmpVerif);
      }
    } catch (Exception e) {
      tmpResult.setException(e);
    }
    return tmpResult;
  }
* 2017-04-18 08:58:39 pdf sign,  named 参考
http://www.massapi.com/class/pd/PdfPKCS7.html

http://blog.csdn.net/wzyzzu/article/details/50546960

工具 http://dl.pconline.com.cn/download/921176.html

# https://security.stackexchange.com/questions/80410/sign-pkcs7-and-verify-pkcs7-signature-with-openssl

http://blog.csdn.net/wzsy/article/details/18217163
http://stackoverflow.com/questions/19410688/pkcs7-signature-verification

http://blog.csdn.net/wzsy/article/details/18217131

http://stackoverflow.com/questions/39507483/signing-a-pdf-with-adbe-pkcs7-detached

https://wenku.baidu.com/view/dd03b98f6bd97f192279e99a.html pdf signed

* 2017-04-17 16:39:57 pdf signature
https://tools.ietf.org/html/rfc5652
https://tools.ietf.org/html/rfc2315 Cryptographic Message Syntax, Version 1.5
https://tools.ietf.org/html/rfc3161
https://tools.ietf.org/html/rfc3281

164.The Acrobat Web Capture plug-in treats external streams referenced within
a PDF file as auxiliary data. Such streams are not used in generating the digital identifier.

2017-04-17 16:39:39 
* developer
foxmail
zhushenglin@sursenelec.com
密码： Sursen@6034 -> Zsl@SS123

\\10.11.16.12\基础产品开发部

http://10.11.15.34:8080/svn/OFD/trunk/

\\10.11.16.12\基础产品开发部\software\朴海镇\Acrobat

* source
BOOL CSSPDFViewView::TestSignPDF_End(char * strInFile, long lOrigFileLength, char * strSignFieldName, BOOL & bContinue, PtrDataInfo pSealData, BOOL bBindCert, char * strCertName)
{
	DocDisplayAttrb *  pdda = GetDocDisplayAttrib();
	if(!pdda)
		return FALSE;	

	long lFileLength = GetFileLength_Win(strInFile);

	int * nbyteranges = pdda->GetSignByteRange(strSignFieldName);
	if(!nbyteranges)
		return FALSE;	

	const char * bDigest = pdda->CalFileDigest(strInFile, nbyteranges[0], nbyteranges[1], nbyteranges[2], nbyteranges[3], 1);	
	if(!bDigest)
	{
		delete [] nbyteranges;
		return FALSE;
	}
	int nDigestLength = strlen(bDigest);

	int dbDigestLength_Bin = 0;
	BYTE * bDigest_Bin = hex2bin((const char *)bDigest, nDigestLength, &dbDigestLength_Bin);

	myStampTool.SetCurrentFileName(strInFile);

	int nSignResultLength = 0;

	const BYTE * strSignResult = NULL;
	if(!bBindCert)
		strSignResult = myStampTool.CalcSignValue((const BYTE *)bDigest, nDigestLength, nSignResultLength);
	else
		strSignResult = GetSignData_SignByCert((const BYTE *)bDigest_Bin, dbDigestLength_Bin, nSignResultLength, strCertName);

	if(!strSignResult || nSignResultLength == 0)
	{
		SetFileLength(strInFile, lOrigFileLength);

		delete [] nbyteranges;
		delete [] bDigest;
		return FALSE;
	}

	DataInfo diSignResult ;
	diSignResult.size = nSignResultLength;
	diSignResult.value = (BYTE *)strSignResult;

	long startpos = nbyteranges[1] + 1;
	long endpos = nbyteranges[2] - 1;

	if(!bBindCert)
		SaveSignValueToFile(pSealData->value, pSealData->size, diSignResult.value, diSignResult.size, strInFile, lOrigFileLength, lFileLength, startpos, endpos);	
	else
		SaveSignValueToFile_Direct(diSignResult.value, diSignResult.size, strInFile,  startpos, endpos);

	delete [] nbyteranges;
	delete [] bDigest;

	delete [] strSignResult;

	GetDocument()->DocumentModified(TRUE);

 

	MessageBox("盖章成功！");
	return TRUE;
}

* emacs
Scancode Map 注册表项来实现键盘按键映射。
位于注册表的：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout\ 下新建一个二进制值项：  "Scancode Map"

这个项目可实现对键盘按键的映射。这里映射的意思可理解为“替换”，可将任意一键替换成其它键。

[项目格式]
以16进制表示，更分为五个部分，每个逗号之间都为一个字节。

# Left-Ctrl -> Caps-Lock
"Scancode Map" = 00,00,00,00,00,00,00,00,   03,00,00,00,   1D,00, 3A,00,   3A,00, 1D,00,    00,00,00,00 

8个字节。 这是版本信息号。照例写就好。
4个字节。 这是映射键的总数。按照二进制的读写规则，低位在左，高位在右。02 00 00 00 这个数实际就是：00 00 00 02 。从 02 开始，一个映射键是 02 ，两个是03 ，依次递加，十个是 0B 。
2个字节。 表示替换后按键的”扫描码“。如：ESC 键的扫描码是 01 ，所以就表示 01 00 。再如 左Ctrl键扫描码是 1D 00, 而右Ctrl键是 1D E0 。
2个字节。 表示原按键的”扫描码“。格式同上。
以四个 00 结束。
* 开源世界
  # find -type f -name *\\.h |xargs grep 2buf
类别 	首选 	备选
发行版 	archlinux 	freeBSD gentoo debian
Shell 	zsh 	bash
终端 	rxvt-unicode 	tilda screen
编辑器 	Emacs 	Vim jed
文档写作 	docbook 	reST muse
版本控制 	git 	svn
加密 	PGP 	truecrypt
窗口管理器 	awesome openbox 	xfce4
浏览器 	Firefox 	liferea
桌面小程序 	conky 	 
输入法 	Fcitx 	scim
下载工具 	aria2 lftp 	wget
播放器 	mplayer w32codecs 	 
图片浏览 	gqview 	 
电子阅读 	evince 	 
词典 	sdcv 	 
文件管理 	tar gzip p7zip 	squeeze unzip unrar
日程管理 	  	osmo
网络服务 	sshd pureftpd 	lighttpd php mysql phpmyadmin
编程 	C python 	ruby lisp
其它 	sudo netcfg 	
* 其他

立春，万物复苏，大地一片生机：

美是百花齐放、美是纯净如一；
和谐是美、突兀是美；
舍己为人是美、物竞天择是美；
大是美，小也是美；
整齐是美，参差是美；
弧线是美、直线是美；
美是无私、美是功利；

风景之美、音乐之美、诗文之美、人之美，从本质上讲是一样的，
带给我们一种舒服的感觉，那感觉充满全身，渗透灵魂，被心苦苦追寻。

爱是恒久忍耐，又有恩慈。爱是不嫉妒，爱是不自夸，不张狂，不做害羞的事，不求自己的益处，不轻易发怒，不计算人的恶，不喜欢不义，只喜欢真理；凡事包容，凡事相信，凡事盼望，凡事忍耐。爱是永不止息。 
——《圣经.新约》哥林多前书十三章四节至八节

万物皆美，皆不美；无善恶美丑；若说有，那也只存在于我们心中
* ubuntu 2017-06-06 09:18:25
** 安装linux 32 & 64 位虚拟机 ubuntu
   http://wiki.ubuntu.org.cn/UbuntuSkills
   # ubuntu32zsl/ununtu64zsl,zsl,try.
1. aptitude可以比apt-get更加智能地解决依赖问题，先安装它.
2. wget
3. $ apt-get install git
   git-el
** 安装通用编译环境 build-essential
   单独安装gcc以及g++比较麻烦，幸运的是，为了能够编译Ubuntu的内核，Ubuntu提供了一个build-essential软件包.
   sudo apt-get install build-essential
** 安装 emacs 以来 xorg-dev, ncurses
   $ sudo yum install gcc* glib* gtk* ncurses* libXpm* giflib* libjpeg* libtiff* libpng* -y
   $ mkdir emacs_build      ## 防止污染源代码
   $ cd emacs_build/
   $ sudo ../emacs-25.1/configure
   $ sudo make && sudo make install
*** 字体：直接从 C:\Windows\Fonts 复制字体文件到 /usr/share/fonts/
   # 新建字体文件夹 emacs
   依次输入以下三条命令：
   sudo mkfontscale
   sudo mkfontdir
   sudo fc-cache -fv
   至此新的字体安装完成
*** 乱码问题
	修改 buffer 编码：
	1、打开文件出现乱码时，可以尝试修改字符的编码：
	M-x revert-buffer-with-coding-system RET（回车）
	然后输入对应编码，如：utf-8 或者 chinese-gbk。
	
	2、在保存的时候还可以指定文件的保存编码：
	M-x set-buffer-file-coding-system
	
	3、查看Emacs编码格式
	M-x describe-coding-system
	# 或者用 unicad.el 自动检测文件编码	(require 'unicad)

** http://wiki.ubuntu.org.cn/IBus
** 安装PDF打印机
sudo apt-get install cups-pdf
#打印生成的pdf文件在 ~/PDF 文件夹里面
** commands, shell, script(perl,)
1. $ dpkg -l  查看已经安装了哪些包
2. 系统更新
   sudo apt-get update (这一步更新包列表)
   sudo apt-get dist-upgrade (这一步安装所有可用更新)
   或者
   sudo apt-get upgrade (这一步安装应用程序更新，不安装新内核等)
3. 查看安装软件时下载包的临时存放目录
   ls /var/cache/apt/archives
4. 快速使用http方式共享目录
   #进入需要共享的目录后运行: 
   python -m SimpleHTTPServer
   #其它电脑使用http://ip:8000 来访问
   #自定义端口为8080: 
   python -m SimpleHTTPServer 8080
5. rar l some.rar
   rar x some.rar
   man rar 
6. uname -a  查看内核
7. 查看系统是32位还是64位
   #查看long的位数，返回32或64
   getconf LONG_BIT
   #查看文件信息，包含32-bit就是32位，包含64-bit就是64位
   file /sbin/init
8. lsb_release -a   查看 ubuntu 版本
9. 各种系统状态
   lsmod 查看内核加载的模块
   lspci 查看PCI设备
   lsusb 查看USB设备
   lsusb -v #加参数 -v 可以显示USB设备的描述表（descriptors）
   lsof -p 进程的pid  查看进程打开的文件
   lsof abc.txt 显示开启文件abc.txt的进程
   lsof -i :22 显示22端口现在运行什么程序
   lsof -c nsd 显示nsd进程现在打开的文件
   ulimit -a 查看系统限制
   df -h, fdisk -l 查看硬盘信息
   du -hs 查看目录占用空间
   top, free, ps -AFL, pstree 查看系统状态
   w 查看目前登入用户运行的程序
   ip addr 网址
10. 清除僵尸进程
    ps -eal | awk '{ if ($2 == "Z") {print $4}}' | xargs sudo kill -9
11. 批量转换src目录下的所有文件内容由GBK到UTF8
	find src -type d -exec mkdir -p utf8/{} \;
	find src -type f -exec iconv -f GBK -t UTF-8 {} -o utf8/{} \;
	mv utf8/* src
	rm -fr utf8
12. 通过ssh传输文件
	scp -rp /path/filename username@remoteIP:/path #将本地文件拷贝到服务器上
	scp -rp username@remoteIP:/path/filename /path #将远程文件从服务器下载到本地
13. 延迟抓图
	gnome-screenshot -d 10 #延迟10秒抓图
	gnome-screenshot -w -d 5 #延迟5秒抓当前激活窗口
* git 代码管理
** 创建新仓库
   创建新文件夹，打开，然后执行 
   git init
   以创建新的 git 仓库。
** 检出仓库
   执行如下命令以创建一个本地仓库的克隆版本：
   git clone /path/to/repository
   如果是远端服务器上的仓库，你的命令会是这个样子：
   git clone username@host:/path/to/repository
** 工作流
   你的本地仓库由 git 维护的三棵“树”组成。
   第一个是你的 工作目录，它持有实际文件；
   第二个是 缓存区（Index），它像个缓存区域，临时保存你的改动；
   最后是 HEAD，指向你最近一次提交后的结果。
   working dir = add => Index(Stage) = commit => HEAD.
** 添加与提交
   改动（把它们添加到缓存区），使用如下命令：
   git add <filename>
   git add *
   ? git add .
   这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：
   git commit -m "代码提交信息"
   现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。
** 推送改动
   你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：
   git push origin master
   可以把 master 换成你想要推送的任何分支。
   
   如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：
   git remote add origin <server>
   如此你就能够将你的改动推送到所添加的服务器上去了。
** 分支
   分支是用来将特性开发绝缘开来的。
   在你创建仓库的时候，master 是“默认的”。
   在其他分支上进行开发，完成后再将它们合并到主分支上。
   
   创建一个叫做“feature_x”的分支，并切换过去：
   git checkout -b feature_x
   切换回主分支：
   git checkout master
   再把新建的分支删掉：
   git branch -d feature_x
   除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：
   git push origin <branch>
** 更新与合并
   更新本地仓库至最新改动，执行：
   git pull
   以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。
   要合并其他分支到你的当前分支（例如 master），执行：
   git merge <branch>
   两种情况下，git 都会尝试去自动合并改动。

   不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）。
   这时候就需要你修改这些文件来人肉合并这些 冲突（conflicts） 了。
   改完之后，你需要执行如下命令以将它们标记为合并成功：
   git add <filename>
   在合并改动之前，也可以使用如下命令查看：
   git diff <source_branch> <target_branch>
** 标签
   在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。
   可以执行如下命令以创建一个叫做 1.0.0 的标签：
   git tag 1.0.0 1b2e1d63ff
   1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID：
   git log
   你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。
** 替换本地改动
   假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动：
   git checkout -- <filename>
   此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。
   
   假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：
   git fetch origin
   git reset --hard origin/master
** 有用的贴士 tips
   内建的图形化 git：
   gitk
   彩色的 git 输出：
   git config color.ui true
   显示历史记录时，只显示一行注释信息：
   git config format.pretty oneline
   交互地添加文件至缓存区：
   git add -i
